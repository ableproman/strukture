<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Strukture - File Tree Generator</title>
    
    <!-- SEO & POPULARITY META TAGS -->
    <meta name="description" content="Strukture - Professional ASCII file tree generator for developers. Visualize folder structures, import from GitHub, and export to ZIP, PNG, or JSON.">
    <meta name="keywords" content="file tree generator, ascii tree, directory structure, folder visualizer, developer tools, github tree import, project structure">
    <meta name="author" content="Strukture App">
    <meta name="robots" content="index, follow">
    
    <!-- SOCIAL / OPEN GRAPH (Popularity) -->
    <meta property="og:title" content="Strukture - File Tree Generator">
    <meta property="og:description" content="The ultimate tool for creating professional ASCII file hierarchies for your documentation.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://strukture.ableproman.hu">
    <meta property="og:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='630' viewBox='0 0 1200 630'%3E%3Crect width='1200' height='630' fill='%23050505'/%3E%3Ctext x='50%25' y='50%25' fill='white' font-family='sans-serif' font-size='80' text-anchor='middle' alignment-baseline='middle'%3EStrukture%3C/text%3E%3C/svg%3E">
    <meta name="twitter:card" content="summary_large_image">
    
    <!-- PWA & MOBILE META TAGS -->
    <meta name="theme-color" content="#141414">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Strukture">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 3h6v6H3zM15 3h6v6h-6zM3 15h6v6H3zM15 15h6v6h-6zM9 6h6M9 18h6M6 9v6M18 9v6'/%3E%3C/svg%3E">

    <!-- GEO META TAGS -->
    <meta name="geo.region" content="HU">
    <meta name="geo.placename" content="Budapest">
    <meta name="geo.position" content="47.4979;19.0402">
    <meta name="ICBM" content="47.4979, 19.0402">

    <script src="jszip.min.js"></script>
    
    <!-- Native SVG Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 3h6v6H3zM15 3h6v6h-6zM3 15h6v6H3zM15 15h6v6h-6zM9 6h6M9 18h6M6 9v6M18 9v6'/%3E%3C/svg%3E">
    <style>
        :root {
            --bg-color: #050505;
            --surface-color: #0f0f0f;
            --panel-color: #141414;
            --border-color: #222222;
            --text-main: #ffffff;
            --text-dim: #666666;
            --accent-color: #ffffff;
            --error-color: #ff4444;
            --warning-color: #ffaa00; /* Added for mixed indentation */
            --tooltip-bg: #141414;
            
            --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: width-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            --ui-font-size: 0.95rem;
            --code-font-size: 1.1rem;
        }

        /* Disable User Selection Everywhere */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Re-enable selection for inputs and textareas so they remain editable */
        textarea, input[type="text"] {
            user-select: text;
            -webkit-user-select: text;
        }

        html, body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-sans);
            height: 100dvh; /* Dynamic Viewport Height for Mobile */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 12px; 
            cursor: default;
          	position: fixed;
        }

        .app-container {
            width: 100%;
            max-width: 100%;
            height: 100%;
            display: grid;
            /* Changed to allow for the 8px resizer bar */
            grid-template-columns: 1fr 8px 1fr;
            gap: 0;
        }

        /* Resizer Bar Styling */
        .resizer {
            grid-column: 2;
            cursor: col-resize;
            background: transparent;
            z-index: 100;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
          	user-select: none;
          	-webkit-user-select: none;
        }
        .resizer:hover, .resizer.active {
            background: rgba(255, 255, 255, 0.05);
        }
        .resizer::after {
            content: '';
            width: 1px;
            height: 20px;
            background: var(--border-color);
        }

        /* NEW: View Toggle Button (Only on Mobile) */
        .view-switcher-btn {
            display: none;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-main);
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 12px;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }
        .view-switcher-btn:active {
            background: rgba(255,255,255,0.1);
        }

        @media (max-width: 1024px) {
            body { 
                padding: 0 !important; 
                height: 100dvh !important; 
                overflow: hidden !important;
            }
            .app-container {
                display: block !important;
                height: 100dvh !important;
                width: 100vw !important;
                position: relative !important;
            }
            .resizer { display: none !important; }
            
            /* Panel becomes full height on mobile */
            .panel {
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100dvh !important;
                border: none !important;
                border-radius: 0 !important;
                display: none !important; /* Hidden by default */
                max-height: none !important; 
            }
            .panel.mobile-active {
                display: flex !important; /* Only active panel shown */
                z-index: 10 !important;
            }

            .view-switcher-btn {
                display: flex !important;
            }

            .panel-content {
                height: 100% !important;
                max-height: none !important;
            }
            .editor-container, .preview-area {
                height: 100% !important;
                max-height: none !important;
            }
        }

        .panel {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed to hidden to contain scrolls */
            position: relative;
        }

        .panel-header {
            padding: 14px 20px;
            background: var(--panel-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap; /* Prevent wrapping to detect collision */
            gap: 10px;
            z-index: 10;
            height: 54px; /* Locked Height */
            min-height: 54px;
            padding-top: calc(14px + env(safe-area-inset-top));
        }

        .panel-title {
            font-size: var(--ui-font-size);
            font-weight: 600;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .breadcrumb-bar {
            background: #0a0a0a;
            padding: 0 20px; /* Reset padding for center align */
            border-bottom: 1px solid var(--border-color);
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-dim);
            white-space: nowrap;
            overflow: hidden;
          	overflow-x: auto;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 8px;
            height: 40px; /* Locked Height */
            min-height: 40px;
        }

        .breadcrumb-bar::-webkit-scrollbar {
            display: none;
        }

        .breadcrumb-item {
            color: var(--text-main);
            opacity: 0.7;
        }
        
        /* NEW: Interactive Breadcrumb Style */
        .breadcrumb-link {
            cursor: pointer;
            transition: opacity 0.1s;
        }
        .breadcrumb-link:hover {
            opacity: 1;
            text-decoration: underline;
        }

        .breadcrumb-sep {
            color: #333;
        }

        .panel-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
            position: relative;
            z-index: 1;
            min-height: 0; /* CRITICAL: Allows flex child to scroll */
        }

        .btn-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: nowrap; /* PREVENT BUTTONS FROM BREAKING INTO NEW LINE */
            overflow: visible;
        }

        /* --- EDITOR STYLING --- */
        .editor-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-main);
            padding: 24px 20px; /* Standardized padding */
            font-family: var(--font-mono);
            font-size: var(--code-font-size);
            line-height: 1.6;
            resize: none;
            outline: none;
            caret-color: var(--accent-color);
            overflow-y: auto; /* Ensure source panel scrolls */
        }

        textarea.drag-over {
            background: rgba(255, 255, 255, 0.03);
            box-shadow: inset 0 0 20px rgba(255,255,255,0.05);
        }

        .preview-area {
            flex: 1;
            background: #080808;
            padding: 0; 
            overflow: auto; /* Ensure tree panel scrolls */
            position: relative;
            min-height: 0; /* CRITICAL: Allows flex child to scroll */
        }

        pre {
            font-family: var(--font-mono);
            font-size: var(--code-font-size);
            line-height: 1.6;
            color: var(--text-main);
            white-space: pre;
            padding: 24px 0;
            min-width: min-content; /* Helps horizontal scrolling */
            counter-reset: tree-counter;
        }

        .tree-line {
            padding: 0 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background 0.1s;
            white-space: pre;
            min-height: 1.6em;
            position: relative;
        }

        /* --- TREE LINE NUMBERS --- */
        .tree-line::before {
            counter-increment: tree-counter;
            content: counter(tree-counter);
            display: inline-block;
            width: 30px; /* Baseline width */
            margin-right: 20px;
            color: var(--text-dim);
            opacity: 0.5; /* Visible line numbers */
            text-align: right;
            font-size: 0.75rem;
            flex-shrink: 0;
            user-select: none;
            pointer-events: none;
        }

        .tree-line:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* --- DRAG AND DROP INDICATORS --- */
        .tree-line.drag-active {
            opacity: 0.4;
            background: rgba(255, 255, 255, 0.05);
        }
        .tree-line.drop-top {
            border-top: 2px solid var(--accent-color);
        }
        .tree-line.drop-bottom {
            border-bottom: 2px solid var(--accent-color);
        }
        .tree-line.drop-into {
            background: rgba(255, 255, 255, 0.1) !important;
            border-radius: 2px;
        }

        .tree-line.duplicate {
            color: var(--error-color);
            text-decoration: underline wavy rgba(255, 68, 68, 0.3);
        }

        /* --- NEW: VALIDATION ENGINE STYLING --- */
        .tree-line.invalid-node {
            color: var(--error-color);
            background: rgba(255, 68, 68, 0.05);
        }
        .validation-warning {
            color: var(--error-color);
            font-weight: 700;
            font-size: 0.65rem;
            display: none;
            margin-right: 10px;
        }
        .validation-warning.visible { display: inline; }

        /* --- Tooltip Styles --- */
        [data-tooltip] {
            position: relative;
        }

        /* UPDATED: Fixed bottom positioning for tooltips */
        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: fixed; /* Changed from absolute */
            bottom: 80px; /* Positioned above toast area */
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: var(--tooltip-bg);
            color: #fff;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.8rem; 
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,1);
            letter-spacing: 0.02em;
            text-transform: none;
            z-index: 2147483647;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* Prevent tooltips from showing during active transitions or clicks */
        .action-btn:active::after {
            opacity: 0 !important;
        }

        /* REMOVED: Specific alignment for end-buttons because tooltips are now center-fixed */

        .action-btn {
            background: transparent;
            color: var(--text-main);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 2px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            display: flex;
            align-items: center;
            text-align-last: center;
            gap: 8px;
            transition: background 0.1s, color 0.1s, border-color 0.1s;
            outline: none;
            position: relative;
            white-space: nowrap;
        }

        .action-btn:hover {
            border-color: var(--text-dim);
            background: rgba(255,255,255,0.02);
        }

        .action-btn.active {
            background: #222;
            border-color: #444;
        }

        select.action-btn {
            appearance: none;
            -webkit-appearance: none;
            padding-right: 32px;
            background-color: transparent;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center; /* LOCKED POSITION */
            cursor: pointer;
            transition: border-color 0.1s, background-color 0.1s;
        }

        select.action-btn option {
            background-color: var(--panel-color);
            color: var(--text-main);
            padding: 12px;
        }

        .copy-btn {
            background: var(--accent-color);
            color: var(--bg-color);
            border-color: var(--accent-color);
        }

        /* Specific hover state to prevent black text disappearing on dark background */
        .copy-btn:hover {
            background: #e0e0e0 !important;
            color: var(--bg-color) !important;
            border-color: #e0e0e0 !important;
        }

        .copy-btn.clicked {
            background: var(--bg-color) !important;
            color: var(--accent-color) !important;
            border-color: var(--border-color) !important;
        }

        .footer-note {
            font-size: 0.75rem;
            color: #444;
            padding: 10px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
            background: var(--surface-color);
        }

        /* NEW: Validation Bar Styles */
        .validation-bar {
            background: var(--error-color);
            color: #fff;
            padding: 10px 20px;
            font-size: 0.8rem;
            font-weight: 700;
            display: none;
            align-items: center;
            gap: 12px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        .validation-bar.visible {
            display: flex;
        }

        .filter-input {
            background: transparent;
            border: 1px solid #222;
            color: #888;
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: 2px;
            width: 200px;
            outline: none;
            font-family: var(--font-mono);
        }

        .filter-input:focus {
            border-color: #444;
            color: #ccc;
        }

        .conflict-warning {
            color: var(--error-color);
            font-weight: 700;
            font-size: 0.65rem;
            display: none;
        }

        .conflict-warning.visible {
            display: inline;
        }

        .indent-warning {
            color: var(--warning-color);
            font-weight: 700;
            font-size: 0.65rem;
            display: none;
            margin-right: 10px;
        }
        .indent-warning.visible { display: inline; }

        .depth-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-dim);
            font-size: 0.75rem;
            font-weight: 600;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 2px;
            background: #222;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 0;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            background: #222;
        }

        .panel:focus-within .status-indicator {
            background: var(--accent-color);
        }

        .icon-svg {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            flex-shrink: 0;
            opacity: 0.7;
            display: inline-block;
            vertical-align: middle;
        }

        /* Stats Badge Styling */
        .stats-badge {
            display: flex;
            gap: 14px;
            color: var(--text-dim);
            font-family: var(--font-mono);
            font-size: 0.7rem;
        }
        .stats-badge span b { color: var(--text-main); font-weight: 600; }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: #2e2e2e;
        }

        #toast {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text-main);
            color: var(--bg-color);
            padding: 12px 24px;
            font-size: 0.9rem;
            font-weight: 600;
            display: none;
            z-index: 1000;
        }

        #toast.visible {
            display: block;
        }

        #folderInput {
            display: none;
        }

        /* --- CUSTOM CONTEXT MENU STYLES --- */
        #customContextMenu {
            position: fixed;
            background: var(--tooltip-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            z-index: 9999;
            padding: 6px 0;
            min-width: 180px;
            display: none;
            border-radius: 4px;
        }

        .context-menu-item {
            padding: 8px 16px;
            color: var(--text-main);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
        }

        .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 6px 0;
        }

        .context-menu-shortcut {
            color: var(--text-dim);
            font-size: 0.7rem;
            margin-left: 20px;
            font-family: var(--font-mono);
        }

        /* --- CUSTOM MODAL STYLES (UPDATED FOR ANIMATION & SCROLLING) --- */
        #modalOverlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
            z-index: 10000;
            display: flex; /* Changed to flex by default, visibility handled by opacity */
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #modalOverlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-box {
            background: var(--panel-color);
            border: 1px solid var(--border-color);
            padding: 30px;
            width: 100%;
            max-width: 550px; /* Slightly wider for legal text */
            max-height: 90%; /* NEW: Height constraint */
            border-radius: 4px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            transform: scale(0.95);
            transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex; /* NEW: Flex structure for scrollable body */
            flex-direction: column;
        }
        #modalOverlay.visible .modal-box {
            transform: scale(1);
        }
        .modal-title {
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 15px;
            color: var(--text-dim);
            flex-shrink: 0; /* Keep header size */
        }
        .modal-body {
            color: var(--text-main);
            font-size: 0.95rem;
            margin-bottom: 25px;
            line-height: 1.5;
            overflow-y: auto; /* NEW: Enable scrolling for long text */
            padding-right: 10px; /* Space for scrollbar */
        }
        /* Custom scrollbar for modal body */
        .modal-body::-webkit-scrollbar { width: 4px; }
        .modal-body::-webkit-scrollbar-thumb { background: #333; border-radius: 10px; }

        .modal-input {
            width: 100%;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            padding: 12px;
            font-family: var(--font-mono);
            outline: none;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            flex-shrink: 0; /* Keep footer size */
        }
        .modal-footer .action-btn {
            font-size: 0.8rem;
            padding: 8px 16px;
        }
        .modal-footer .primary {
            background: var(--accent-color);
            color: var(--bg-color);
            border-color: var(--accent-color);
        }

        /* Collapsed folder indicator */
        .folder-chevron {
            width: 12px;
            margin-right: 4px;
            transition: transform 0.2s;
            opacity: 0.5;
        }
        .tree-line.collapsed .folder-chevron {
            transform: rotate(-90deg);
        }

        /* --- HAMBURGER & MOBILE MENU NEW STYLES --- */
        .hamburger-btn {
            display: none;
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: color 0.2s, background 0.2s;
        }
        .hamburger-btn:hover {
            color: var(--text-main);
            background: rgba(255,255,255,0.05);
        }
        
        /* UPDATED: Mobile menu overlay with slide animation and scroll */
        .mobile-menu {
            display: flex;
            position: absolute;
            top: 54px; /* Matches header height */
            left: 0;
            right: 0;
            background: #111;
            /* REMOVED: border-bottom line as requested */
            flex-direction: column;
            padding: 0 20px;
            overflow: hidden;
            overflow-y: auto; /* NEW: Enable vertical scrolling */
            max-height: 0;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), padding 0.4s;
            z-index: 100; /* Overlays breadcrumb and content */
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
        
        .mobile-menu.open {
            max-height: 70dvh; /* NEW: Constraint height for scrolling */
            padding-top: 12px;
            padding-bottom: 12px;
        }
        
        .mobile-menu .btn-group {
            width: 100%;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            flex-wrap: wrap; /* Allow wrapping only inside the mobile dropdown */
        }
        .mobile-menu .btn-group .action-btn {
            justify-content: center;
            height: 38px;
            font-size: 0.8rem;
        }
        .mobile-menu select.action-btn {
            background-position: right 16px center;
        }

        @media print {
            body {
                background: white !important;
                color: black !important;
                padding: 0 !important; height: auto !important; overflow: visible !important;
            }
            .app-container { display: block !important; }
            #sourcePanel, .panel-header, .footer-note, .breadcrumb-bar, #toast, .resizer { display: none !important; }
            .panel { border: none !important; background: white !important; }
            .preview-area { background: white !important; padding: 0 !important; overflow: visible !important; }
            pre { color: black !important; font-size: 10pt !important; }
            .tree-line { padding: 0 !important; }
            @page { margin: 2cm; }
        }

        /* --- NEW: TREE ACTIONS & HOVER ICONS --- */
        .tree-line-actions {
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            height: 100%;
            padding: 0 4px;
            opacity: 0;
            transition: opacity 0.1s;
            background: var(--surface-color);
            z-index: 5;
        }
        .tree-line:hover .tree-line-actions {
            opacity: 1;
        }
        .action-icon-btn {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-dim);
            transition: color 0.1s;
            border-radius: 2px;
        }
        .action-icon-btn:hover {
            color: var(--text-main);
            background: rgba(255,255,255,0.1);
        }
        .action-icon-btn.trash:hover {
            color: var(--error-color);
        }
        .tree-line-actions svg {
            width: 12px;
            height: 12px;
            margin: 0;
        }

        /* --- NEW: FILE ANNOTATIONS & LIVE SEARCH STYLES --- */
        .tree-annotation {
            font-style: italic;
            font-size: 0.8em;
            opacity: 0.4;
            margin-left: 12px;
            font-family: var(--font-sans);
            pointer-events: none;
        }
        .tree-search-bar {
            padding: 0 20px; /* Reset padding for center align */
            background: #0a0a0a;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 10px;
            height: 40px; /* Locked Height */
            min-height: 40px;
        }
        .tree-search-input {
            flex: 1;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-main);
            font-size: 0.75rem;
            padding: 6px 10px;
            border-radius: 2px;
            outline: none;
            font-family: var(--font-mono);
            transition: border-color 0.2s;
        }
        .tree-search-input:focus {
            border-color: #444;
        }
        .tree-line.hidden-search {
            display: none;
        }

        /* MOBILE HEADER & MENU OVERRIDES FOR PWA USABILITY */
        @media (max-width: 1024px) {
            .panel-header {
                height: 72px !important; /* Increased height for mobile */
                min-height: 72px !important;
                padding-bottom: 28px !important;
            }
            .mobile-menu {
                top: 85px !important; /* Positioned precisely under the larger header */
            }
        }
    </style>
</head>
<body>

    <input type="file" id="folderInput" webkitdirectory directory>

    <!-- CUSTOM MODAL HTML -->
    <div id="modalOverlay">
        <div class="modal-box" id="modalBox">
            <div class="modal-title" id="modalTitle">Alert</div>
            <div class="modal-body" id="modalBody">Message goes here.</div>
            <input type="text" id="modalInput" class="modal-input" style="display:none">
            <div class="modal-footer" id="modalFooter">
                <button class="action-btn" id="modalCancel">Cancel</button>
                <button class="action-btn primary" id="modalConfirm">OK</button>
            </div>
        </div>
    </div>

    <!-- CUSTOM CONTEXT MENU HTML -->
    <div id="customContextMenu">
        <div class="context-menu-item" onclick="copyToClipboard()">
            <span>Copy Output</span>
            <span class="context-menu-shortcut">CTRL+C</span>
        </div>
        <div class="context-menu-item" onclick="copyAsMarkdown()">
            <span>Copy as MD</span>
        </div>
        <div class="context-menu-divider"></div>
        <!-- NEW: Auto-Refactor Entry -->
        <div class="context-menu-item" onclick="runMagicThree()">
            <span>Auto-Refactor</span>
            <span class="context-menu-shortcut">MAGIC 3</span>
        </div>
        <div class="context-menu-item" onclick="fixIndentation()">
            <span>Fix Indentation</span>
        </div>
        <div class="context-menu-item" onclick="autoSortSource()">
            <span>Alphabetical Sort</span>
        </div>
        <div class="context-menu-item" onclick="autoFixFolders()">
            <span>Auto-Slash Folders</span>
        </div>
        <div class="context-menu-item" onclick="clearInput()">
            <span>Clear Input</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="downloadZipStructure()">
            <span>Export ZIP</span>
        </div>
        <div class="context-menu-item" onclick="exportAsPNG()">
            <span>Save PNG Image</span>
        </div>
        <div class="context-menu-item" onclick="exportAsSVG()">
            <span>Save SVG Vector</span>
        </div>
    </div>

    <div class="app-container" id="appContainer">
        <!-- Source Panel -->
        <div class="panel mobile-active" id="sourcePanel">
            <div class="panel-header" id="sourceHeader">
                <div class="panel-title">
                    <!-- NEW View Switcher on the left for phones -->
                    <button class="view-switcher-btn" onclick="switchView('tree')">
                        <svg class="icon-svg" style="margin:0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                    </button>
                    <div class="status-indicator"></div>
                    Source
                </div>
                <!-- Hamburger for Source -->
                <button class="hamburger-btn" id="sourceHamburger" onclick="toggleMobileMenu('source')">
                    <svg class="icon-svg" style="margin:0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                </button>
                <div class="btn-group" id="sourceBtns">
                    <!-- NEW HELP BUTTON -->
                    <button class="action-btn" data-tooltip="User manual and guide" onclick="showHelp()">
                        Help
                    </button>
                    <!-- NEW: Consolidated Legal Select -->
                    <select class="action-btn" id="legalSelect" data-tooltip="Legal information and policies" onchange="handleLegalSelect(this.value)">
                        <option value="">Legal</option>
                        <option value="privacy">Privacy</option>
                        <option value="terms">Terms</option>
                        <option value="impressum">Impressum</option>
                    </select>
                    <button class="action-btn" data-tooltip="Import tree structure from a public GitHub repository" onclick="importFromGitHub()">
                        GitHub Import
                    </button>
                    <select class="action-btn" id="templateSelect" data-tooltip="Load a pre-defined project structure" onchange="loadTemplate(this.value)">
                        <option value="">Templates</option>
                        <option value="web">Modern Web</option>
                        <option value="react">React App</option>
                        <option value="vue">Vue.js App</option>
                        <option value="laravel">Laravel PHP</option>
                        <option value="django">Django App</option>
                        <option value="flutter">Flutter Pkg</option>
                        <option value="python">Python Pkg</option>
                        <option value="node">Node.js API</option>
                    </select>
                    <button class="action-btn" data-tooltip="Import a folder directory from your computer" onclick="document.getElementById('folderInput').click()">
                        Select Folder
                    </button>
                    <!-- NEW: Consolidated Tools Select -->
                    <select class="action-btn" id="toolsSelect" data-tooltip="Refactoring tools" onchange="handleToolsSelect(this.value)">
                        <option value="">Tools</option>
                        <option value="sort">Auto-Sort</option>
                        <option value="indent">Fix Indent</option>
                        <option value="slash">Auto-Slash</option>
                    </select>
                    <!-- NEW: Magic 3 Button -->
                    <button class="action-btn" data-tooltip="Run Fix Indent, Auto-Sort, and Auto-Slash with one click" onclick="runMagicThree()">
                        Auto-Refactor
                    </button>
                    <!-- NEW: DB Buttons -->
                    <button class="action-btn" data-tooltip="Save this structure to your browser database" onclick="saveToDB()">
                        Save
                    </button>
                    <button class="action-btn" data-tooltip="View your saved structures" onclick="showSavedStructures()">
                        My Structures
                    </button>
                    <button class="action-btn" data-tooltip="Generate a shareable link for this tree" onclick="shareLink()">
                        Share
                    </button>
                    <!-- NEW: Consolidated AI Select -->
                    <select class="action-btn primary" id="aiSelect" data-tooltip="AI powered features" onchange="handleAISelect(this.value)">
                        <option value="">AI Features</option>
                        <option value="generate">AI Architect</option>
                        <option value="audit">AI Review</option>
                        <option value="config">AI Config</option>
                    </select>
                    <button class="action-btn" data-tooltip="Wipe all text from the input area" onclick="clearInput()">
                        Clear
                    </button>
                </div>
            </div>
            <!-- Mobile Menu for Source -->
            <div class="mobile-menu" id="sourceMobileMenu"></div>
            
            <div class="breadcrumb-bar" id="breadcrumb">
                <span class="breadcrumb-item">project</span>
            </div>
            <div class="panel-content">
                <!-- SOURCE TEXTAREA WITH PLACEHOLDER -->
                <div class="editor-container">
                    <textarea id="inputArea" spellcheck="false" placeholder="root/&#10;  folder/ // add annotations like this&#10;    file.ext&#10;&#10;Drop a folder or use 'Select Folder'...&#10;# This is a comment" onkeyup="handleTextChange()" onmouseup="handleTextChange()" onfocus="handleTextChange()"></textarea>
                </div>
            </div>
            <div class="footer-note">
                <input type="text" id="filterInput" class="filter-input" data-tooltip="Comma separated names to ignore during import" placeholder="Exclude: .git, node_modules..." value=".git, node_modules, .DS_Store, dist, build">
                <span>HIERARCHY EDITOR</span>
            </div>
        </div>

        <!-- Draggable Resizer -->
        <div class="resizer" id="resizer"></div>

        <!-- Tree Panel -->
        <div class="panel" id="treePanel">
            <div class="panel-header" id="treeHeader">
                <div class="panel-title">
                    <!-- NEW View Switcher on the left for phones -->
                    <button class="view-switcher-btn" onclick="switchView('source')">
                        <svg class="icon-svg" style="margin:0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                    </button>
                    <div class="status-indicator"></div>
                    Tree
                </div>
                <!-- Hamburger for Tree -->
                <button class="hamburger-btn" id="treeHamburger" onclick="toggleMobileMenu('tree')">
                    <svg class="icon-svg" style="margin:0" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                </button>
                <div class="btn-group" id="treeBtns">
                    <button class="action-btn" id="toggleIconsBtn" data-tooltip="Show or hide file and folder icons" onclick="toggleIcons()">
                        Icons
                    </button>
                    <!-- NEW: Full Path Toggle Button -->
                    <button class="action-btn" id="fullPathToggleBtn" data-tooltip="Toggle showing full relative paths instead of names" onclick="toggleFullPaths()">
                        Full Paths
                    </button>
                    <!-- NEW: Extension Filter Button -->
                    <button class="action-btn" id="filterExtBtn" data-tooltip="Hide specific file extensions from the tree view" onclick="showExtensionFilter()">
                        Filter
                    </button>
                    <!-- NEW: Reverse Parser Button -->
                    <button class="action-btn" data-tooltip="Paste a raw ASCII tree to convert it back to source format" onclick="showReverseParser()">
                        Reverse Parser
                    </button>
                    <select class="action-btn" id="styleSelect" data-tooltip="Change the ASCII connector character set" onchange="generateTree()">
                        <option value="round">Round</option>
                        <option value="modern">Modern</option>
                        <option value="classic">Classic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                    <button class="action-btn" data-tooltip="Generate shell command to create this structure locally" onclick="exportCLI()">
                        CLI Tool
                    </button>
                    <!-- NEW: Mermaid.js Export Button -->
                    <button class="action-btn" data-tooltip="Export as Mermaid.js diagram code" onclick="exportMermaid()">
                        Mermaid
                    </button>
                    <!-- NEW: README Generator Button -->
                    <button class="action-btn" data-tooltip="Generate a project README.md from the tree" onclick="generateReadme()">
                        README Gen
                    </button>
                    <button class="action-btn" data-tooltip="Generate and download the actual empty folder & file structure as a ZIP archive" onclick="downloadZipStructure()">
                        Zip
                    </button>
                    <!-- NEW: Consolidated Export Select -->
                    <select class="action-btn" id="exportSelect" data-tooltip="Export tree in various formats" onchange="handleExport(this.value)">
                        <option value="">Export As</option>
                        <option value="json">JSON Data</option>
                        <option value="xml">XML Hierarchy</option>
                        <option value="png">PNG Image</option>
                        <option value="svg">SVG Vector</option>
                    </select>
                    <button class="action-btn" data-tooltip="Copy tree wrapped in Markdown code tags" onclick="copyAsMarkdown()">
                        MD
                    </button>
                    <button class="action-btn copy-btn" id="copyBtn" data-tooltip="Copy raw ASCII tree to clipboard" onclick="copyToClipboard()">
                        Copy Output
                    </button>
                </div>
            </div>
            <!-- Mobile Menu for Tree -->
            <div class="mobile-menu" id="treeMobileMenu"></div>

            <!-- SEARCH BAR -->
            <div class="tree-search-bar">
                <input type="text" id="treeSearchInput" class="tree-search-input" placeholder="Live search tree..." onkeyup="handleTreeSearch()">
            </div>

            <div class="panel-content">
                <div class="preview-area">
                    <pre id="outputArea" onclick="handlePreviewClick(event)"></pre>
                </div>
            </div>
            <!-- NEW: Validation Bar -->
            <div id="validationBar" class="validation-bar">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" cy="8" x2="12" y2="12"/><line x1="12" cy="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                <span id="validationBarMessage">Folders must end with / and files cannot contain children.</span>
            </div>
            <div class="footer-note">
                <div class="depth-slider-container">
                    <span id="validWarn" class="validation-warning">INVALID NAMES</span>
                    <span id="indentWarn" class="indent-warning" data-tooltip="Mixed spaces and tabs detected!">MIXED INDENT</span>
                    <span id="conflictWarn" class="conflict-warning">NAMING CONFLICTS DETECTED</span>
                    <div class="stats-badge" id="statsBadge">
                        <span>DIRS: <b id="folderCount">0</b></span>
                        <span>FILES: <b id="fileCount">0</b></span>
                    </div>
                    DEPTH LIMIT: <span id="depthVal">MAX</span>
                    <input type="range" id="depthSlider" min="1" max="11" value="11" oninput="updateDepth(this.value)">
                </div>
                <span>ASCII FORMAT</span>
            </div>
        </div>
    </div>

    <div id="toast">COPIED TO CLIPBOARD</div>

    <script>
        const inputArea = document.getElementById('inputArea');
        const outputArea = document.getElementById('outputArea');
        const copyBtn = document.getElementById('copyBtn');
        const toast = document.getElementById('toast');
        const depthSlider = document.getElementById('depthSlider');
        const depthVal = document.getElementById('depthVal');
        const folderInput = document.getElementById('folderInput');
        const styleSelect = document.getElementById('styleSelect');
        const breadcrumb = document.getElementById('breadcrumb');
        const filterInput = document.getElementById('filterInput');
        const conflictWarn = document.getElementById('conflictWarn');
        const indentWarn = document.getElementById('indentWarn');
        const toggleIconsBtn = document.getElementById('toggleIconsBtn');
        const resizer = document.getElementById('resizer');
        const appContainer = document.getElementById('appContainer');
        const customMenu = document.getElementById('customContextMenu');
        const treeSearchInput = document.getElementById('treeSearchInput');

        let showIcons = true;
        let showFullPaths = false; // NEW STATE
        let hiddenExtensions = new Set(); // NEW STATE: Extension Filtering
        if (showIcons) toggleIconsBtn.classList.add('active');

        const SVG_ICONS = {
            folder: `<svg class="icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2z"></path></svg>`,
            file: `<svg class="icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>`
        };

        const INITIAL_EXAMPLE = `project/
  backend/
    db_config.php // MySQL Connection
  logs/
    errors.log // Log files here
  public/
    api/
      api.php
    index.html
    style.css // Global styles
    script.js
    README.md
    .env`;

        // Updated templates with strictly standard 2-space indentation
        const TEMPLATES = {
            web: "project/\n  index.html\n  assets/\n    images/\n    styles/\n      main.css\n    js/\n      app.js\n  vendor/\n  README.md",
            react: "my-app/\n  src/\n    components/\n      Layout.jsx\n      Header.jsx\n    assets/\n    hooks/\n    App.js\n    index.css\n  public/\n    favicon.ico\n  package.json\n  .gitignore",
            vue: "vue-project/\n  public/\n  src/\n    assets/\n    components/\n      HelloWorld.vue\n    views/\n      AboutView.vue\n    App.vue\n    main.js\n  package.json\n  vite.config.js",
            laravel: "laravel-app/\n  app/\n    Http/Controllers/\n    Models/\n  config/\n  database/\n    migrations/\n  public/\n  resources/\n    js/\n    views/\n  routes/\n    api.php\n    web.php\n  .env\n  artisan",
            django: "my_django_project/\n  manage.py\n  project_name/\n    __init__.py\n    settings.py\n    urls.py\n    wsgi.py\n  app_name/\n    migrations/\n    __init__.py\n    admin.py\n    models.py\n    views.py",
            flutter: "my_flutter_app/\n  android/\n  ios/\n  lib/\n    main.dart\n    src/\n  test/\n  web/\n  pubspec.yaml\n  README.md",
            python: "my_package/\n  __init__.py\n  core.py\n  utils.py\n  tests/\n    test_core.py\n  requirements.txt\n  setup.py\n  README.md",
            node: "api-server/\n  src/\n    controllers/\n    models/\n    routes/\n    middleware/\n    app.js\n  config/\n    db.js\n  .env\n  package.json\n  docker-compose.yml"
        };

        // REVERTED: Connector visual width back to original 4-char style
        const CONNECTOR_STYLES = {
            round: { branch: " ", last: " ", line: "   ", spacer: "    " },
            modern: { branch: " ", last: " ", line: "   ", spacer: "    " },
            classic: { branch: "|-- ", last: "\\-- ", line: "|   ", spacer: "    " },
            minimal: { branch: "+-- ", last: "+-- ", line: "|   ", spacer: "    " }
        };

        // --- NEW: Custom Modal System (WITH ANIMATION LOGIC) ---
        const modalOverlay = document.getElementById('modalOverlay');
        const modalBox = document.getElementById('modalBox');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalInput = document.getElementById('modalInput');
        const modalCancel = document.getElementById('modalCancel');
        const modalConfirm = document.getElementById('modalConfirm');

        let modalResolve = null;

        function showModal({ title = 'Alert', message = '', hasInput = false, inputPlaceholder = '', showCancel = true, confirmText = 'OK' }) {
            return new Promise((resolve) => {
                modalConfirm.style.display = 'block'; // RESET VISIBILITY IN CASE PREVIOUS MODAL HID IT
                modalTitle.innerText = title;
                // FIX: Use innerHTML to allow strong/h3 tags for professional legal docs
                modalBody.innerHTML = message;
                modalInput.style.display = hasInput ? 'block' : 'none';
                modalInput.value = '';
                modalInput.placeholder = inputPlaceholder;
                modalCancel.style.display = showCancel ? 'block' : 'none';
                modalConfirm.innerText = confirmText;
                
                // Reset scroll position to top when opening a new modal
                modalBody.scrollTop = 0;
                
                // Add visible class to trigger CSS transition
                modalOverlay.classList.add('visible');
                
                modalResolve = resolve;
                if (hasInput) setTimeout(() => modalInput.focus(), 150);
            });
        }

        modalConfirm.onclick = () => {
            const val = modalInput.style.display !== 'none' ? modalInput.value : true;
            modalOverlay.classList.remove('visible'); // Trigger fade out
            if (modalResolve) modalResolve(val);
        };

        modalCancel.onclick = () => {
            modalOverlay.classList.remove('visible'); // Trigger fade out
            if (modalResolve) modalResolve(null);
        };

        // Custom wrappers
        const customAlert = (msg) => showModal({ message: msg, showCancel: false });
        const customConfirm = (msg) => showModal({ message: msg, title: 'Confirm' });
        const customPrompt = (msg, placeholder) => showModal({ message: msg, title: 'Input Required', hasInput: true, inputPlaceholder: placeholder });

        // --- NEW: Folder Collapsing State ---
        let collapsedPaths = new Set();

        // --- UPDATED: ROBUST MOBILE VIEW SWITCHER ---
        function switchView(target) {
            const sourcePanel = document.getElementById('sourcePanel');
            const treePanel = document.getElementById('treePanel');
            
            // Explicit Class Toggling
            if (target === 'tree') {
                sourcePanel.classList.remove('mobile-active');
                treePanel.classList.add('mobile-active');
            } else {
                treePanel.classList.remove('mobile-active');
                sourcePanel.classList.add('mobile-active');
            }
            
            // Force a layout refresh and collision check
            requestAnimationFrame(() => {
                window.dispatchEvent(new Event('resize'));
                checkHeaderCollisions();
            });
        }

        // --- UPDATED: GitHub Import Logic (WITH DUPLICATE PREVENTION) ---
        async function importFromGitHub() {
            const repoUrl = await customPrompt("Enter public GitHub Repository URL (e.g., https://github.com/user/repo):", "https://github.com/...");
            if (!repoUrl) return;

            try {
                // Parse URL
                const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
                if (!match) throw new Error("Invalid GitHub URL");

                const [_, owner, repo] = match;
                const cleanRepo = repo.replace(/\.git$/, "");
                
                showToast("FETCHING REPO...");
                
                // Fetch recursive tree
                const response = await fetch(`https://api.github.com/repos/${owner}/${cleanRepo}/git/trees/main?recursive=1`);
                if (!response.ok) throw new Error("Could not fetch tree (Repo might be private or branch is not 'main')");

                const data = await response.json();
                const exclusions = getExclusions();
                
                let result = `${cleanRepo}/\n`;
                const seenPaths = new Set();
                
                // Filter duplicates and exclusions
                const tree = data.tree.filter(item => {
                    if (seenPaths.has(item.path)) return false;
                    seenPaths.add(item.path);
                    return !exclusions.some(ex => item.path.includes(ex));
                });
                
                // Sort by path
                tree.sort((a, b) => a.path.localeCompare(b.path));

                tree.forEach(item => {
                    const parts = item.path.split('/');
                    const depth = parts.length;
                    const name = parts[parts.length - 1];
                    const isDir = item.type === 'tree';
                    result += "  ".repeat(depth) + name + (isDir ? "/" : "") + "\n";
                });

                inputArea.value = result.trim();
                generateTree();
                updateBreadcrumb();
                showToast("GITHUB REPO IMPORTED");
            } catch (e) {
                customAlert("GitHub Import Error: " + e.message);
            }
        }

        // --- Editor: Tab & Auto-Indent Support ---
        inputArea.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = inputArea.selectionStart;
                const end = inputArea.selectionEnd;
                // Insert 2 spaces for tab
                const tab = "  ";
                inputArea.value = inputArea.value.substring(0, start) + tab + inputArea.value.substring(end);
                inputArea.selectionStart = inputArea.selectionEnd = start + tab.length;
                handleTextChange();
            }
            
            // NEW: Auto-Indent on Enter
            if (e.key === 'Enter') {
                const start = inputArea.selectionStart;
                const end = inputArea.selectionEnd;
                const value = inputArea.value;
                
                // Find start of current line to copy its indentation
                const lineStart = value.lastIndexOf('\n', start - 1) + 1;
                const currentLine = value.substring(lineStart, start);
                
                // Match leading whitespace
                const whitespaceMatch = currentLine.match(/^\s*/);
                const whitespace = whitespaceMatch ? whitespaceMatch[0] : "";
                
                e.preventDefault();
                const insertion = "\n" + whitespace;
                inputArea.value = value.substring(0, start) + insertion + value.substring(end);
                
                const newPos = start + insertion.length;
                inputArea.setSelectionRange(newPos, newPos);
                handleTextChange();
            }
        });

        // --- Custom Context Menu Logic ---
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const { clientX: x, clientY: y } = e;
            
            customMenu.style.left = `${x}px`;
            customMenu.style.top = `${y}px`;
            customMenu.style.display = 'block';

            // Ensure menu doesn't go off screen
            const menuWidth = customMenu.offsetWidth;
            const menuHeight = customMenu.offsetHeight;
            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            if (x + menuWidth > winWidth) customMenu.style.left = `${winWidth - menuWidth - 10}px`;
            if (y + menuHeight > winHeight) customMenu.style.top = `${winHeight - menuHeight - 10}px`;
        });

        window.addEventListener('click', () => {
            customMenu.style.display = 'none';
        });

        // --- Resizer Logic ---
        let isResizing = false;
        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizer.classList.add('active');
            document.body.style.cursor = 'col-resize';
        });

        window.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerRect = appContainer.getBoundingClientRect();
            const offset = e.clientX - containerRect.left;
            const percentage = (offset / containerRect.width) * 100;
            if (percentage > 15 && percentage < 85) {
                appContainer.style.gridTemplateColumns = `${percentage}% 8px 1fr`;
            }
            checkHeaderCollisions(); // Check collisions while resizing
        });

        window.addEventListener('mouseup', () => {
            isResizing = false;
            resizer.classList.remove('active');
            document.body.style.cursor = 'default';
        });

        // --- Template Logic ---
        function loadTemplate(key) {
            if (TEMPLATES[key]) {
                inputArea.value = TEMPLATES[key];
                // Automatically fix indentation to ensure tree parses correctly
                fixIndentation(); 
                handleTextChange();
            }
        }

        async function compressData(str) {
            const stream = new Blob([str]).stream();
            const compressedStream = stream.pipeThrough(new CompressionStream('deflate'));
            const res = await new Response(compressedStream).blob();
            const buffer = await res.arrayBuffer();
            return btoa(String.fromCharCode(...new Uint8Array(buffer)))
                .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        async function decompressData(base64) {
            try {
                const normalized = base64.replace(/-/g, '+').replace(/_/g, '/');
                const bin = atob(normalized);
                const buffer = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) buffer[i] = bin.charCodeAt(i);
                const stream = new Blob([buffer]).stream();
                const decompressedStream = stream.pipeThrough(new DecompressionStream('deflate'));
                return await new Response(decompressedStream).text();
            } catch (e) {
                return decodeURIComponent(escape(atob(base64)));
            }
        }

        // NEW: Debounce Timer for Auto-Save
        let autoSaveTimer = null;

        function handleTextChange() {
            generateTree();
            updateBreadcrumb();
            saveHistory(); // NEW: Track for Undo/Redo

            // NEW: Trigger Auto-Save every time user stops typing (1 second delay)
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                autoSaveToDB();
            }, 1000);
        }

        function toggleIcons() {
            showIcons = !showIcons;
            toggleIconsBtn.classList.toggle('active', showIcons);
            generateTree();
        }

        // NEW: Toggle Full Path Visibility
        function toggleFullPaths() {
            showFullPaths = !showFullPaths;
            document.getElementById('fullPathToggleBtn').classList.toggle('active', showFullPaths);
            generateTree();
        }

        // --- NEW: Extension Filtering Logic ---
        function showExtensionFilter() {
            const common = ['.html', '.css', '.js', '.json', '.md', '.png', '.jpg', '.php', '.py', '.env'];
            modalTitle.innerText = "EXTENSION FILTERING";
            modalBody.innerHTML = `
                <div style="margin-bottom: 12px; font-size: 0.85rem; color: var(--text-dim);">Select file extensions to HIDE from the tree view:</div>
                <div id="extFilterGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; margin-bottom: 20px;">
                    ${common.map(ext => `
                        <button class="action-btn ${hiddenExtensions.has(ext) ? 'active' : ''}" 
                                style="justify-content: center; text-transform: lowercase; font-size: 0.7rem;" 
                                onclick="toggleExtensionFilter('${ext}', this)">${ext}</button>
                    `).join('')}
                </div>
                <div style="margin-bottom: 12px; font-size: 0.85rem; color: var(--text-dim);">Or type custom (e.g. .tmp, .bak):</div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="customExtInput" class="modal-input" style="margin-bottom: 0;" placeholder=".extension">
                    <button class="action-btn primary" onclick="addCustomExtension()">Add</button>
                </div>
                <div style="margin-top: 15px; border-top: 1px solid var(--border-color); padding-top: 15px;">
                     <button class="action-btn" style="width: 100%; justify-content: center;" onclick="hiddenExtensions.clear(); generateTree(); modalOverlay.classList.remove('visible'); showToast('ALL FILTERS REMOVED');">Show All Files</button>
                </div>
            `;
            modalInput.style.display = 'none';
            modalCancel.style.display = 'none';
            modalConfirm.innerText = "DONE";
            modalConfirm.style.display = 'block'; // FIX: Ensure button is visible after being hidden by Share
            modalOverlay.classList.add('visible');
        }

        function toggleExtensionFilter(ext, btn) {
            if (hiddenExtensions.has(ext)) {
                hiddenExtensions.delete(ext);
                btn.classList.remove('active');
            } else {
                hiddenExtensions.add(ext);
                btn.classList.add('active');
            }
            generateTree();
        }

        function addCustomExtension() {
            const input = document.getElementById('customExtInput');
            let val = input.value.trim().toLowerCase();
            if (val) {
                if (!val.startsWith('.')) val = '.' + val;
                hiddenExtensions.add(val);
                input.value = '';
                showExtensionFilter(); // Refresh modal view
                generateTree();
            }
        }

        function handlePreviewClick(e) {
            const line = e.target.closest('.tree-line');
            if (!line) return;

            // NEW: Handle specific button clicks within the preview line
            const trashBtn = e.target.closest('.action-icon-btn.trash');
            const toggleBtn = e.target.closest('.action-icon-btn.toggle');
            const index = parseInt(line.dataset.index);
            const isFolder = line.dataset.isFolder === 'true';
            const currentPath = line.dataset.fullPath;

            if (trashBtn) {
                e.stopPropagation();
                handleDeleteNode(index);
                return;
            }

            if (toggleBtn || (isFolder && e.clientX - line.getBoundingClientRect().left < 80)) {
                e.stopPropagation();
                if (collapsedPaths.has(currentPath)) collapsedPaths.delete(currentPath);
                else collapsedPaths.add(currentPath);
                generateTree();
                return;
            }

            jumpToLine(index);
        }

        // UPDATED: Now only selects the name of the folder or file (excluding extension)
        function jumpToLine(index) {
            const text = inputArea.value;
            const lines = text.split('\n');
            
            let charPos = 0;
            for (let i = 0; i < index; i++) {
                charPos += (lines[i] ? lines[i].length : 0) + 1;
            }

            const currentLineText = lines[index] || "";
            const indentSize = currentLineText.search(/\S/);
            
            // If no text, return. If text exists, skip indent.
            if (indentSize === -1) {
                inputArea.focus();
                inputArea.setSelectionRange(charPos, charPos + currentLineText.length);
            } else {
                const selectionStart = charPos + indentSize;
                let lineContent = currentLineText.trim();
                
                // Handle comments/annotations to avoid selecting them
                const commentIdx = lineContent.indexOf('//');
                if (commentIdx !== -1) lineContent = lineContent.substring(0, commentIdx).trim();
                const hashIdx = lineContent.indexOf('#');
                if (hashIdx !== -1 && lineContent.startsWith('#')) lineContent = "";
                else if (hashIdx !== -1) lineContent = lineContent.substring(0, hashIdx).trim();

                let nameToSelect = lineContent;
                if (nameToSelect.endsWith('/')) {
                    // It's a folder, strip the trailing slash
                    nameToSelect = nameToSelect.slice(0, -1);
                } else if (nameToSelect) {
                    // It's a file, find the last dot to strip extension
                    const lastDot = nameToSelect.lastIndexOf('.');
                    // Don't strip if dot is at index 0 (hidden file like .env) or not present
                    if (lastDot > 0) {
                        nameToSelect = nameToSelect.substring(0, lastDot);
                    }
                }

                inputArea.focus();
                inputArea.setSelectionRange(selectionStart, selectionStart + nameToSelect.length);
            }
            
            const lineHeight = parseFloat(getComputedStyle(inputArea).lineHeight);
            inputArea.scrollTop = index * lineHeight - (inputArea.clientHeight / 2);
            updateBreadcrumb();
        }

        // --- NEW: INTERACTIVE BREADCRUMB LOGIC ---
        function updateBreadcrumb() {
            const text = inputArea.value;
            const cursorPos = inputArea.selectionStart;
            const lines = text.split('\n');
            
            let currentLineIndex = 0;
            let currentChars = 0;
            for(let i=0; i<lines.length; i++) {
                currentChars += lines[i].length + 1;
                if (currentChars > cursorPos) {
                    currentLineIndex = i;
                    break;
                }
            }

            // FILTER COMMENTS FROM BREADCRUMB
            const parsed = lines.map((l, idx) => {
                let name = l;
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) name = name.substring(0, dsIdx);
                name = name.trim();
                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    isComment: isIgnored || name === "",
                    lineIndex: idx
                };
            });
            
            const currentLine = parsed[currentLineIndex];
            if (!currentLine || currentLine.name === "" || currentLine.isComment) return;

            let path = [{ name: currentLine.name, lineIndex: currentLine.lineIndex }];
            let lastIndent = currentLine.indent;

            for(let i = currentLineIndex - 1; i >= 0; i--) {
                if (!parsed[i].isComment && parsed[i].indent < lastIndent && parsed[i].indent >= 0 && parsed[i].name !== "") {
                    path.unshift({ name: parsed[i].name, lineIndex: parsed[i].lineIndex });
                    lastIndent = parsed[i].indent;
                }
            }

            breadcrumb.innerHTML = path.map((item, idx) => {
                const isLast = idx === path.length - 1;
                // Added breadcrumb-link class and jumpToLine call
                return `<span class="breadcrumb-item breadcrumb-link" onclick="jumpToLine(${item.lineIndex})">${item.name}</span>${isLast ? '' : '<span class="breadcrumb-sep">/</span>'}`;
            }).join('');
        }

        // --- UPDATED: Scoped Duplicate Naming Logic (FIXED SYNTAX) ---
        function findConflicts(nodes) {
            const conflicts = new Set();
            const seenMap = new Map(); // Map<ParentIndex, Map<Name, LineIndex>>

            // Use a stack to track parents at different indentation levels
            const parentStack = [{ indent: -1, index: -1 }];

            nodes.forEach((node, idx) => {
                const { indent, name } = node;
                if (name === "") return;

                // Adjust stack to find the correct parent for the current indentation
                while (parentStack.length > 1 && parentStack[parentStack.length - 1].indent >= indent) {
                    parentStack.pop();
                }

                const parent = parentStack[parentStack.length - 1];
                const parentKey = parent.index; // Unique ID for the current folder

                if (!seenMap.has(parentKey)) {
                    seenMap.set(parentKey, new Map());
                }

                const folderContents = seenMap.get(parentKey);
                
                if (folderContents.has(name)) {
                    conflicts.add(idx);
                    conflicts.add(folderContents.get(name));
                } else {
                    folderContents.set(name, idx);
                }

                // Push current node as potential parent for next lines
                parentStack.push({ indent: indent, index: idx });
            });

            return conflicts;
        }

        // --- DRAG AND DROP HANDLERS ---
        let dragSrcIndex = -1;

        function handleDragStart(e, index) {
            dragSrcIndex = index;
            e.target.classList.add('drag-active');
            e.dataTransfer.setData('text/plain', index);
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            const el = e.target.closest('.tree-line');
            if (!el) return;

            const rect = el.getBoundingClientRect();
            const relY = (e.clientY - rect.top) / rect.height;
            
            el.classList.remove('drop-top', 'drop-bottom', 'drop-into');
            
            // If dragging over a folder name, allow "into" dropping
            const isFolder = el.innerText.trim().endsWith('/') || el.dataset.isFolder === "true";

            if (isFolder && relY > 0.25 && relY < 0.75) {
                el.classList.add('drop-into');
            } else if (relY < 0.5) {
                el.classList.add('drop-top');
            } else {
                el.classList.add('drop-bottom');
            }
        }

        function handleDragLeave(e) {
            const el = e.target.closest('.tree-line');
            if (el) el.classList.remove('drop-top', 'drop-bottom', 'drop-into');
        }

        function handleDrop(e, targetIdx) {
            e.preventDefault();
            const el = e.target.closest('.tree-line');
            if (!el) return;

            const rect = el.getBoundingClientRect();
            const relY = (e.clientY - rect.top) / rect.height;
            const type = el.classList.contains('drop-into') ? 'into' : (relY < 0.5 ? 'before' : 'after');
            
            el.classList.remove('drop-top', 'drop-bottom', 'drop-into');
            
            if (dragSrcIndex === -1 || dragSrcIndex === targetIdx) return;

            moveStructure(dragSrcIndex, targetIdx, type);
        }

        function moveStructure(srcIdx, targetIdx, mode) {
            const rawLines = inputArea.value.split('\n');
            const nodes = rawLines.map(l => ({ indent: l.search(/\S/), text: l }));
            
            // Get range of lines for the source (node + all children)
            let srcEnd = srcIdx + 1;
            while (srcEnd < nodes.length && nodes[srcEnd].indent > nodes[srcIdx].indent) {
                srcEnd++;
            }
            const movedLines = rawLines.slice(srcIdx, srcEnd);
            const sourceIndent = nodes[srcIdx].indent;

            // Remove from original
            rawLines.splice(srcIdx, srcEnd - srcIdx);

            // Re-calculate new insertion index after removal
            let insertionIdx = (targetIdx > srcIdx) ? targetIdx - (srcEnd - srcIdx) : targetIdx;
            
            // Determine target indentation
            let targetIndent = 0;
            const updatedNodes = rawLines.map(l => ({ indent: l.search(/\S/), text: l }));
            const targetNode = updatedNodes[insertionIdx];

            if (mode === 'into') {
                targetIndent = targetNode.indent + 2;
                insertionIdx++; // Place at start of folder contents
            } else if (mode === 'after') {
                targetIndent = targetNode.indent;
                // Move insertion to the end of the target's subtree
                let search = insertionIdx + 1;
                while (search < updatedNodes.length && updatedNodes[search].indent > targetNode.indent) {
                    search++;
                }
                insertionIdx = search;
            } else {
                targetIndent = targetNode.indent;
            }

            // Adjust indentation of moved block
            const indentDiff = targetIndent - sourceIndent;
            const adjustedLines = movedLines.map(line => {
                if (line.trim() === "") return "";
                const currentIndent = line.search(/\S/);
                const newIndent = Math.max(0, currentIndent + indentDiff);
                return " ".repeat(newIndent) + line.trim();
            });

            // Insert
            rawLines.splice(insertionIdx, 0, ...adjustedLines);
            
            inputArea.value = rawLines.join('\n');
            handleTextChange();
        }

        // --- UPDATED: VALIDATION ENGINE LOGIC (WINDOWS COMPLIANCE & ARCHITECTURE CHECK) ---
        function validateNodes(nodes) {
            const invalidIndices = new Set();
            const illegalChars = /[<>:"\\|?*]/; // Common illegal chars for filenames
            let architectureError = false; // Track the new child-of-file error
            
            nodes.forEach((node, idx) => {
                if (node.isComment) return;
                const cleanName = node.name.replace(/\/$/, "");
                if (illegalChars.test(cleanName)) {
                    invalidIndices.add(idx);
                }

                // NEW ARCHITECTURAL CHECK: File-as-Folder
                // If the next node is more indented, the current node MUST end with a slash
                const nextNode = nodes[idx + 1];
                if (nextNode && !nextNode.isComment && nextNode.indent > node.indent) {
                    if (!node.name.endsWith('/')) {
                        invalidIndices.add(idx);
                        architectureError = true;
                    }
                }
            });
            
            // NEW: Toggle the red validation bar
            const validationBar = document.getElementById('validationBar');
            if (architectureError) {
                validationBar.classList.add('visible');
            } else {
                validationBar.classList.remove('visible');
            }

            return invalidIndices;
        }

        // UPDATED: Depth now caps at (parentDepth + 1) to prevent "infinite space" drift in tree preview
        function buildTreeHTML(nodes) {
            if (nodes.length === 0) return "";
            
            const style = CONNECTOR_STYLES[styleSelect.value] || CONNECTOR_STYLES.round;
            const maxDepth = parseInt(depthSlider.value);
            const searchTerm = treeSearchInput.value.toLowerCase();
            
            // ONLY PROCESS NON-COMMENT NODES FOR THE TREE
            const activeNodes = nodes.filter(n => !n.isComment && (n.name !== "" || n.annotation !== ""));
            const conflicts = findConflicts(activeNodes);
            
            // --- NEW: VALIDATION CHECK ---
            const invalidNodes = validateNodes(activeNodes);
            document.getElementById('validWarn').classList.toggle('visible', invalidNodes.size > 0);

            conflictWarn.classList.toggle('visible', conflicts.size > 0);

            let indentUnit = 0;
            const indents = activeNodes.map(n => n.indent).filter(i => i > 0);
            if (indents.length > 0) {
                indentUnit = Math.min(...indents);
            }

            let html = "";
            let fCount = 0;
            let fileCount = 0;

            // Track current path stack for collapsing logic
            let currentPathStack = [];
            // Track last logical depth to clamp over-indentation
            let lastLogicalDepth = -1;

            // Pre-calculate visibility based on search for folders
            const matchesSearch = activeNodes.map(node => 
                (node.name + " " + node.annotation).toLowerCase().includes(searchTerm)
            );

            activeNodes.forEach((node, index) => {
                const { indent, name, annotation } = node;
                if (name === "" && annotation === "") return;

                // Logical Clamping: If user types excessive spaces, limit depth to parent + 1
                const rawDepth = indentUnit > 0 ? Math.floor(indent / indentUnit) : 0;
                const depth = Math.min(rawDepth, lastLogicalDepth + 1);
                lastLogicalDepth = depth;
                
                // Track path for collapsing
                while (currentPathStack.length > depth) currentPathStack.pop();
                // FIX: Strip slash for stack to avoid double slash join
                currentPathStack[depth] = (name || "(annotation)").replace(/\/$/, "");

                // NEW: Extension Filter Check
                // Move isFolder up to assist pathing
                const isFolder = (name !== "" && name.endsWith('/')) || hasFollowingSibling(activeNodes, index, depth + 1, indentUnit, maxDepth, true);
                const fullPath = currentPathStack.slice(0, depth + 1).join('/') + (isFolder ? "/" : "");

                if (!isFolder && name.includes('.') && hiddenExtensions.size > 0) {
                    const parts = name.split('.');
                    const ext = "." + parts[parts.length - 1].toLowerCase();
                    if (hiddenExtensions.has(ext)) return;
                }

                // LIVE SEARCH FILTERING LOGIC:
                // If there's a search term, only show node if:
                // 1. It matches the search
                // 2. Any of its descendants match the search
                let isVisibleBySearch = true;
                if (searchTerm) {
                    isVisibleBySearch = matchesSearch[index] || hasMatchingDescendant(activeNodes, index, indent, matchesSearch);
                }

                // Check if any parent in the stack is collapsed
                let isHiddenByCollapse = false;
                for (let i = 0; i < depth; i++) {
                    const parentPath = currentPathStack.slice(0, i + 1).join('/') + "/";
                    if (collapsedPaths.has(parentPath)) {
                        isHiddenByCollapse = true;
                        break;
                    }
                }

                if (isHiddenByCollapse) return;

                if (maxDepth < 11 && depth >= maxDepth) return;

                let prefix = "";
                let isLast = false;

                if (depth > 0) {
                    for (let i = 0; i < depth - 1; i++) {
                        const hasMore = hasFollowingSibling(activeNodes, index, i + 1, indentUnit, maxDepth);
                        // Using reverted style logic
                        prefix += hasMore ? style.line : style.spacer;
                    }
                    isLast = !hasFollowingSibling(activeNodes, index, depth, indentUnit, maxDepth);
                    prefix += isLast ? style.last : style.branch;
                }
                
                // Track Stats
                if (isFolder) fCount++; else if (name !== "") fileCount++;

                const isCollapsed = collapsedPaths.has(fullPath);
                
                // Hover Action Buttons (Trash and Toggle)
                const actionButtons = `
                    <div class="tree-line-actions">
                        <div class="action-icon-btn trash" title="Delete">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                        </div>
                        ${isFolder ? `
                        <div class="action-icon-btn toggle" title="${isCollapsed ? 'Expand' : 'Collapse'}">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="${isCollapsed ? 'M9 6l6 6-6 6' : 'M6 9l6 6 6-6'}"/>
                            </svg>
                        </div>` : ''}
                    </div>`;

                const chevron = isFolder ? `<svg class="folder-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>` : `<span style="width:16px"></span>`;
                const icon = showIcons ? (isFolder ? SVG_ICONS.folder : (name === "" ? "" : SVG_ICONS.file)) : "";
                const annotationHTML = annotation ? `<span class="tree-annotation">// ${annotation}</span>` : "";
                
                const isConflict = conflicts.has(index);
                const isInvalid = invalidNodes.has(index);
                
                const originalIndex = nodes.indexOf(node);
                const displayName = showFullPaths ? fullPath : name;

                html += `<div class="tree-line${isConflict ? ' duplicate' : ''}${isInvalid ? ' invalid-node' : ''}${isCollapsed ? ' collapsed' : ''}${!isVisibleBySearch ? ' hidden-search' : ''}" 
                             data-index="${originalIndex}" 
                             data-is-folder="${isFolder}"
                             data-full-path="${fullPath}"
                             draggable="true" 
                             ondragstart="handleDragStart(event, ${index})" 
                             ondragover="handleDragOver(event)" 
                             onmouseleave="handleDragLeave(event)"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, ${index})">${actionButtons}${prefix}${chevron}${icon}${displayName}${annotationHTML}</div>`;
            });

            document.getElementById('folderCount').innerText = fCount;
            document.getElementById('fileCount').innerText = fileCount;

            return html;
        }

        // Helper for live search to keep parents of matches visible
        function hasMatchingDescendant(nodes, startIndex, parentIndent, matches) {
            for (let i = startIndex + 1; i < nodes.length; i++) {
                if (nodes[i].indent <= parentIndent) break;
                if (matches[i]) return true;
            }
            return false;
        }

        function hasFollowingSibling(nodes, currentIndex, depth, indentUnit, maxDepth, immediateOnly = false) {
            const targetIndent = depth * indentUnit;
            for (let i = currentIndex + 1; i < nodes.length; i++) {
                if ((nodes[i].name === "" && nodes[i].annotation === "") || nodes[i].isComment) continue;
                if (nodes[i].indent < targetIndent) return false;
                if (nodes[i].indent === targetIndent) {
                    const nodeDepth = indentUnit > 0 ? Math.floor(nodes[i].indent / indentUnit) : 0;
                    if (maxDepth < 11 && nodeDepth >= maxDepth) continue;
                    return true;
                }
                if (immediateOnly && nodes[i].indent > (depth - 1) * indentUnit) return true;
                if (immediateOnly) return false;
            }
            return false;
        }

        function updateDepth(val) {
            depthVal.innerText = val > 10 ? "MAX" : val;
            generateTree();
        }

        // --- Data Parsers for JSON/XML ---
        function getNestedObject() {
            const rawLines = inputArea.value.split('\n');
            const nodes = rawLines.map(l => {
                let name = l;
                let annotation = "";
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) {
                    annotation = name.substring(dsIdx + 2).trim();
                    name = name.substring(0, dsIdx);
                }
                name = name.trim();
                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    annotation: annotation,
                    isComment: isIgnored || (name === "" && annotation === "")
                };
            }).filter(n => (n.name || n.annotation) && !n.isComment);

            let indentUnit = 0;
            const indents = nodes.map(n => n.indent).filter(i => i > 0);
            if (indents.length > 0) indentUnit = Math.min(...indents);
            if (indentUnit === 0) indentUnit = 2;

            const root = { name: "root", children: [], type: "folder" };
            const stack = [root];

            nodes.forEach((node, index) => {
                const depth = Math.floor(node.indent / indentUnit);
                const isFolder = node.name.endsWith('/') || hasFollowingSibling(nodes, index, depth + 1, indentUnit, 999, true);
                const item = { 
                    name: node.name.replace(/\/$/, "") || (node.annotation ? `// ${node.annotation}` : ""), 
                    type: isFolder ? "folder" : "file" 
                };
                if (isFolder) item.children = [];

                while (stack.length > depth + 1) stack.pop();
                stack[stack.length - 1].children.push(item);
                if (isFolder) stack.push(item);
            });
            return root.children;
        }

        function exportJSON() {
            const data = getNestedObject();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = "structure.json"; a.click();
            showToast("JSON EXPORTED");
        }

        function exportXML() {
            const data = getNestedObject();
            const buildXML = (items) => {
                return items.map(item => {
                    if (item.type === 'folder') {
                        return `<folder name="${item.name}">${buildXML(item.children)}</folder>`;
                    }
                    return `<file name="${item.name}" />`;
                }).join('');
            };
            const xmlStr = `<?xml version="1.0" encoding="UTF-8"?>\n<structure>\n${buildXML(data)}\n</structure>`;
            const blob = new Blob([xmlStr], { type: "text/xml" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = "structure.xml"; a.click();
            showToast("XML EXPORTED");
        }

        // NEW: Handle Combined Export Selection
        function handleExport(val) {
            if (!val) return;
            switch(val) {
                case 'json': exportJSON(); break;
                case 'xml': exportXML(); break;
                case 'png': exportAsPNG(); break;
                case 'svg': exportAsSVG(); break;
            }
            document.getElementById('exportSelect').value = ""; // Reset dropdown
        }

        // Mermaid.js Export Logic
        function exportMermaid() {
            const data = getNestedObject();
            let mermaidStr = "graph TD\n";
            let nodeCount = 0;

            const traverse = (items, parentId = "root_node") => {
                items.forEach(item => {
                    nodeCount++;
                    const currentId = `n${nodeCount}`;
                    const label = item.name.replace(/"/g, '\\"');
                    mermaidStr += `  ${currentId}["${label}"]\n`;
                    mermaidStr += `  ${parentId} --> ${currentId}\n`;
                    if (item.type === 'folder' && item.children) {
                        traverse(item.children, currentId);
                    }
                });
            };

            mermaidStr += `  root_node["/"]\n`;
            traverse(data);

            showModal({
                title: "MERMAID.JS EXPORT",
                message: "Copy this code into a Mermaid-compatible editor (like mermaid.live):",
                confirmText: "CLOSE"
            });
            const body = document.getElementById('modalBody');
            body.innerHTML += `
                <div style="margin-top:15px">
                    <div style="background: #000; padding: 10px; border: 1px solid var(--border-color); font-family: var(--font-mono); font-size: 0.75rem; color: #0f0; overflow-y: auto; max-height: 200px; white-space: pre; cursor: pointer; border-radius: 4px;" onclick="copyInternal(this.innerText); showToast('MERMAID COPIED')">${mermaidStr}</div>
                </div>
            `;
        }

        // CLI TOOL EXPORT (CROSS-PLATFORM SUPPORT)
        function exportCLI() {
            const data = getNestedObject();
            let bashCmds = [];
            let psCmds = [];
            
            const traverse = (items, parentPath = "") => {
                items.forEach(item => {
                    const currentPath = parentPath ? `${parentPath}/${item.name}` : item.name;
                    const winPath = currentPath.replace(/\//g, '\\');
                    
                    if (item.type === 'folder') {
                        bashCmds.push(`mkdir -p "${currentPath}"`);
                        psCmds.push(`New-Item -ItemType Directory -Force -Path "${winPath}"`);
                        if (item.children) traverse(item.children, currentPath);
                    } else {
                        bashCmds.push(`touch "${currentPath}"`);
                        psCmds.push(`New-Item -ItemType File -Force -Path "${winPath}"`);
                    }
                });
            };
            
            traverse(data);
            const bashString = bashCmds.join(' && ');
            const psString = psCmds.join('; ');
            
            showModal({
                title: "CLI COMMAND GENERATOR",
                message: "Copy and run the command block for your specific environment:",
                confirmText: "DONE"
            });
            
            const body = document.getElementById('modalBody');
            body.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.7rem; color: var(--text-dim); font-weight: bold; margin-bottom: 6px;">BASH / ZSH (Linux, macOS):</div>
                    <div style="background: #000; padding: 10px; border: 1px solid var(--border-color); font-family: var(--font-mono); font-size: 0.75rem; color: #0f0; overflow-x: auto; white-space: pre; cursor: pointer; border-radius: 4px;" onclick="copyInternal(this.innerText); showToast('BASH COPIED')">${bashString}</div>
                </div>
                <div>
                    <div style="font-size: 0.7rem; color: var(--text-dim); font-weight: bold; margin-bottom: 6px;">POWERSHELL / CMD (Windows):</div>
                    <div style="background: #000; padding: 10px; border: 1px solid var(--border-color); font-family: var(--font-mono); font-size: 0.75rem; color: #0f0; overflow-x: auto; white-space: pre; cursor: pointer; border-radius: 4px;" onclick="copyInternal(this.innerText); showToast('PS COPIED')">${psString}</div>
                </div>
                <div style="margin-top: 10px; font-size: 0.7rem; color: var(--text-dim); text-align: center;">Click a block to copy. Commands use -Force to prevent errors if items already exist.</div>
            `;
        }

        // CALCULATION INDEPENDENT OF DOM SCRAPING
        // UPDATED: Added logical clamping here as well
        function getRawASCIIArray() {
            const rawLines = inputArea.value.split('\n');
            const nodes = rawLines.map(l => {
                let name = l;
                let annotation = "";
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) {
                    annotation = name.substring(dsIdx + 2).trim();
                    name = name.substring(0, dsIdx);
                }
                name = name.trim();
                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    annotation: annotation,
                    isComment: isIgnored || (name === "" && annotation === "")
                };
            });

            const style = CONNECTOR_STYLES[styleSelect.value] || CONNECTOR_STYLES.round;
            const maxDepth = parseInt(depthSlider.value);
            const activeNodes = nodes.filter(n => !n.isComment && (n.name !== "" || n.annotation !== ""));
            
            let indentUnit = 0;
            const indents = activeNodes.map(n => n.indent).filter(i => i > 0);
            if (indents.length > 0) indentUnit = Math.min(...indents);
            
            const results = [];
            let currentPathStack = [];
            let lastLogicalDepth = -1;

            activeNodes.forEach((node, index) => {
                const rawDepth = indentUnit > 0 ? Math.floor(node.indent / indentUnit) : 0;
                const depth = Math.min(rawDepth, lastLogicalDepth + 1);
                lastLogicalDepth = depth;

                if (maxDepth < 11 && depth >= maxDepth) return;

                while (currentPathStack.length > depth) currentPathStack.pop();
                currentPathStack[depth] = (node.name || "(annotation)").replace(/\/$/, "");
                
                const isFolder = (node.name !== "" && node.name.endsWith('/')) || hasFollowingSibling(activeNodes, index, depth + 1, indentUnit, maxDepth, true);
                const fullPath = currentPathStack.slice(0, depth + 1).join('/') + (isFolder ? "/" : "");

                let linePrefix = "";
                if (depth > 0) {
                    for (let i = 0; i < depth - 1; i++) {
                        const hasMore = hasFollowingSibling(activeNodes, index, i + 1, indentUnit, maxDepth);
                        // Using style spacers (reverted width)
                        linePrefix += hasMore ? style.line : style.spacer;
                    }
                    const isLast = !hasFollowingSibling(activeNodes, index, depth, indentUnit, maxDepth);
                    linePrefix += isLast ? style.last : style.branch;
                }
                
                const displayBase = showFullPaths ? fullPath : node.name;
                const displayName = displayBase + (node.annotation ? ` // ${node.annotation}` : "");

                results.push({
                    text: linePrefix + displayName,
                    prefix: linePrefix,
                    nameOnly: displayName,
                    isFolder: isFolder
                });
            });
            return results;
        }

        // FIXED PNG EXPORT
        function exportAsPNG() {
            const treeData = getRawASCIIArray();
            if (treeData.length === 0) return;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const lineHeight = 28;
            const padding = 60;
            const monoFont = '18px "ui-monospace", "SFMono-Regular", Menlo, Monaco, Consolas, monospace';
            ctx.font = monoFont;
            
            let maxWidth = 0;
            treeData.forEach(line => {
                let w = ctx.measureText(line.text).width;
                if (showIcons) w += 28; 
                if (w > maxWidth) maxWidth = w;
            });
            
            canvas.width = maxWidth + (padding * 2);
            canvas.height = (treeData.length * lineHeight) + (padding * 2);
            
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = monoFont;
            ctx.fillStyle = '#ffffff';
            ctx.textBaseline = 'middle';
            
            treeData.forEach((line, i) => {
                const y = padding + (i * lineHeight) + (lineHeight / 2);
                const x = padding;
                
                if (showIcons) {
                    ctx.fillText(line.prefix, x, y);
                    const prefixWidth = ctx.measureText(line.prefix).width;
                    const iconX = x + prefixWidth + 2;
                    const iconY = y - 8;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.7;
                    
                    if (line.isFolder) { 
                        ctx.strokeRect(iconX, iconY + 2, 16, 12);
                        ctx.beginPath();
                        ctx.moveTo(iconX, iconY + 2);
                        ctx.lineTo(iconX + 6, iconY + 2);
                        ctx.lineTo(iconX + 8, iconY);
                        ctx.lineTo(iconX + 16, iconY);
                        ctx.stroke();
                    } else if (!line.nameOnly.startsWith('//')) { 
                        ctx.strokeRect(iconX + 2, iconY, 12, 16);
                        ctx.beginPath();
                        ctx.moveTo(iconX + 10, iconY);
                        ctx.lineTo(iconX + 14, iconY + 4);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                    ctx.fillText(line.nameOnly, (line.isFolder || !line.nameOnly.startsWith('//')) ? iconX + 24 : iconX, y);
                } else {
                    ctx.fillText(line.text, x, y);
                }
            });
            
            const link = document.createElement('a');
            link.download = 'structure.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            showToast("PNG EXPORTED");
        }

        // SVG EXPORT LOGIC
        function exportAsSVG() {
            const treeData = getRawASCIIArray();
            if (treeData.length === 0) return;

            const lineHeight = 28;
            const padding = 60;
            const fontSize = 18;
            const charWidth = 10.8; 

            let maxWidth = 0;
            treeData.forEach(line => {
                let w = line.text.length * charWidth;
                if (showIcons) w += 30;
                if (w > maxWidth) maxWidth = w;
            });

            const width = maxWidth + (padding * 2);
            const height = (treeData.length * lineHeight) + (padding * 2);

            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
            svgContent += `<rect width="100%" height="100%" fill="#050505"/>`;
            svgContent += `<style>
                .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: ${fontSize}px; fill: #ffffff; }
                .icon { stroke: #ffffff; stroke-width: 1.5; fill: none; opacity: 0.7; }
            </style>`;

            treeData.forEach((line, i) => {
                const y = padding + (i * lineHeight) + (lineHeight / 2) + 6; 
                const x = padding;

                if (showIcons) {
                    const prefix = line.prefix;
                    svgContent += `<text x="${x}" y="${y}" class="mono">${prefix.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</text>`;
                    
                    const prefixWidth = prefix.length * charWidth;
                    const iconX = x + prefixWidth + 4;
                    const iconY = y - 16;

                    if (line.isFolder) {
                        svgContent += `<g class="icon" transform="translate(${iconX}, ${iconY})">
                            <path d="M2 18h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-7.93c-.6 0-1.16-.27-1.52-.73L7.73 2.07C7.37 1.61 6.81 1.34 6.21 1.34H2c-1.1 0-2 .9-2 2V16c0 1.1.9 2 2 2z"/>
                        </g>`;
                    } else if (!line.nameOnly.startsWith('//')) {
                        svgContent += `<g class="icon" transform="translate(${iconX + 2}, ${iconY - 2})">
                            <path d="M11 0H4C2.9 0 2 .9 2 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V7L11 0z"/>
                            <polyline points="11 0 11 7 18 7" transform="translate(-2,0)"/>
                        </g>`;
                    }

                    const nameX = (line.isFolder || !line.nameOnly.startsWith('//')) ? iconX + 28 : iconX;
                    svgContent += `<text x="${nameX}" y="${y}" class="mono">${line.nameOnly.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</text>`;
                } else {
                    svgContent += `<text x="${x}" y="${y}" class="mono">${line.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</text>`;
                }
            });

            svgContent += `</svg>`;

            const blob = new Blob([svgContent], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "structure.svg";
            a.click();
            showToast("SVG EXPORTED");
        }

        function downloadZipStructure() {
            if (typeof JSZip === 'undefined') {
                showToast("JSZip library not found locally.");
                return;
            }
            
            const rawLines = inputArea.value.split('\n');
            const nodes = rawLines.map(l => {
                let name = l;
                let annotation = "";
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) {
                    annotation = name.substring(dsIdx + 2).trim();
                    name = name.substring(0, dsIdx);
                }
                name = name.trim();
                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    isComment: isIgnored || (name === "" && annotation === "")
                };
            }).filter(n => !n.isComment && n.name !== "");
            
            if (nodes.length === 0 || (nodes.length === 1 && nodes[0].name === "")) {
                showToast("NO STRUCTURE TO DOWNLOAD");
                return;
            }

            const zip = new JSZip();
            let indentUnit = 0;
            const indents = nodes.map(n => n.indent).filter(i => i > 0);
            if (indents.length > 0) indentUnit = Math.min(...indents);
            if (indentUnit === 0) indentUnit = 2;

            const pathStack = [];

            nodes.forEach((node, index) => {
                if (node.name === "") return;
                const depth = Math.floor(node.indent / indentUnit);
                
                while (pathStack.length > depth) {
                    pathStack.pop();
                }

                const cleanName = node.name.replace(/\/$/, "");
                const currentPath = [...pathStack, cleanName].join("/");
                const isFolder = node.name.endsWith('/') || hasFollowingSibling(nodes, index, depth + 1, indentUnit, 999, true);

                if (isFolder) {
                    zip.folder(currentPath);
                    pathStack.push(cleanName);
                } else {
                    zip.file(currentPath, "");
                }
            });

            zip.generateAsync({type:"blob"}).then(function(content) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "project_structure.zip";
                link.click();
                showToast("ZIP DOWNLOADED");
            }).catch(e => {
                showToast("ERROR GENERATING ZIP");
            });
        }

        // ZERO-LOSS COMMENT-AWARE INDENTATION FIX
        function fixIndentation() {
            const rawLines = inputArea.value.split('\n');
            if (rawLines.length === 0) return;

            const nodes = rawLines.map(l => ({ 
                indent: l.search(/\S/), 
                content: l.trim() 
            }));
            
            let indentUnit = 0;
            const indents = nodes.filter(n => n.indent > 0).map(n => n.indent);
            if (indents.length > 0) indentUnit = Math.min(...indents);
            if (indentUnit === 0) indentUnit = 2;

            const fixed = nodes.map(node => {
                if (node.content === "") return "";
                const depth = Math.floor(node.indent / indentUnit);
                return "  ".repeat(depth) + node.content;
            }).join('\n');

            inputArea.value = fixed;
            generateTree();
        }

        // Alphabetical Auto-Sort Logic (FIXED TO PRESERVE ALL COMMENTS)
        function autoSortSource() {
            const rawLines = inputArea.value.split('\n');
            const nodes = rawLines.map(l => {
                let name = l;
                let annotation = "";
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) {
                    annotation = name.substring(dsIdx + 2).trim();
                    name = name.substring(0, dsIdx);
                }
                name = name.trim();

                const sortKey = name.replace(/\/$/, "").toLowerCase();

                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    annotation: annotation,
                    sortKey: sortKey,
                    originalLine: l.trim(),
                    isComment: isIgnored || (name === "" && annotation === "")
                };
            });

            if (nodes.length === 0) return;

            function buildHierarchy(startIndex, currentIndent) {
                const siblings = [];
                let i = startIndex;

                while (i < nodes.length) {
                    const node = nodes[i];
                    if (node.originalLine === "") { i++; continue; }
                    if (node.indent < currentIndent) break;

                    if (node.indent === currentIndent) {
                        const sibling = { ...node, children: [] };
                        i++;
                        if (i < nodes.length && nodes[i].indent > currentIndent) {
                            const { children, nextIndex } = buildHierarchy(i, nodes[i].indent);
                            sibling.children = children;
                            i = nextIndex;
                        }
                        siblings.push(sibling);
                    } else {
                        i++;
                    }
                }
                
                siblings.sort((a, b) => {
                    if (a.isComment && !b.isComment) return -1;
                    if (!a.isComment && b.isComment) return 1;
                    if (a.isComment && b.isComment) return a.originalLine.localeCompare(b.originalLine);
                    
                    const aIsDir = a.name.endsWith('/') || a.children.length > 0;
                    const bIsDir = b.name.endsWith('/') || b.children.length > 0;
                    
                    if (aIsDir && !bIsDir) return -1;
                    if (!aIsDir && bIsDir) return 1;
                    
                    return a.sortKey.localeCompare(b.sortKey, undefined, { numeric: true });
                });

                return { children: siblings, nextIndex: i };
            }

            function flattenHierarchy(items) {
                let text = "";
                items.forEach(item => {
                    text += " ".repeat(Math.max(0, item.indent)) + item.originalLine + "\n";
                    if (item.children.length > 0) {
                        text += flattenHierarchy(item.children);
                    }
                });
                return text;
            }

            const roots = [];
            let cursor = 0;
            while (cursor < nodes.length) {
                if (nodes[cursor].originalLine !== "" && nodes[cursor].indent <= 0) {
                   const { children, nextIndex } = buildHierarchy(cursor, Math.max(0, nodes[cursor].indent));
                   roots.push(...children);
                   cursor = nextIndex;
                } else {
                    cursor++;
                }
            }

            inputArea.value = flattenHierarchy(roots).trim();
            generateTree();
        }

        // Folder Slasher (COMMENT SAFE)
        function autoFixFolders() {
            const rawLines = inputArea.value.split('\n');
            const nodes = rawLines.map(l => {
                let name = l;
                let annotation = "";
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) {
                    annotation = name.substring(dsIdx + 2).trim();
                    name = name.substring(0, dsIdx);
                }
                name = name.trim();
                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    annotation: annotation,
                    originalText: l,
                    isComment: isIgnored || (name === "" && annotation === "")
                };
            });

            let indentUnit = 0;
            const indents = nodes.filter(n => !n.isComment && n.indent > 0).map(n => n.indent);
            if (indents.length > 0) indentUnit = Math.min(...indents);
            if (indentUnit === 0) indentUnit = 2;

            const fixed = nodes.map((node, idx) => {
                if (node.isComment) return node.originalText;
                
                const depth = Math.floor(node.indent / indentUnit);
                const isFolder = node.name.endsWith('/') || hasFollowingSibling(nodes, idx, depth + 1, indentUnit, 999, true);
                
                if (isFolder && !node.name.endsWith('/')) {
                    const line = " ".repeat(node.indent) + node.name + "/";
                    return node.annotation ? `${line} // ${node.annotation}` : line;
                }
                
                return node.originalText;
            }).join('\n');

            inputArea.value = fixed;
            generateTree();
        }

        // NEW: Handle Combined Tools Selection
        function handleToolsSelect(val) {
            if (!val) return;
            if (val === 'sort') autoSortSource();
            else if (val === 'indent') fixIndentation();
            else if (val === 'slash') autoFixFolders();
            document.getElementById('toolsSelect').value = ""; // Reset dropdown
        }

        // NEW: Handle Combined AI Selection
        function handleAISelect(val) {
            if (!val) return;
            if (val === 'generate') generateWithAI();
            else if (val === 'audit') auditWithAI();
            else if (val === 'config') configureAI();
            document.getElementById('aiSelect').value = ""; // Reset dropdown
        }

        // NEW: Handle Combined Legal Selection
        function handleLegalSelect(val) {
            if (!val) return;
            if (val === 'privacy') showPrivacy();
            else if (val === 'terms') showTerms();
            else if (val === 'impressum') window.open('https://ableproman.hu/impressum', '_blank');
            document.getElementById('legalSelect').value = ""; // Reset dropdown
        }

        function getExclusions() {
            return filterInput.value.split(',').map(s => s.trim()).filter(s => s.length > 0);
        }

        folderInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            const exclusions = getExclusions();
            const filteredFiles = files.filter(file => {
                const parts = file.webkitRelativePath.split('/');
                return !parts.some(p => exclusions.includes(p));
            });

            filteredFiles.sort((a, b) => a.webkitRelativePath.localeCompare(b.webkitRelativePath));
            let currentPath = [];
            let output = "";
            filteredFiles.forEach(file => {
                const pathParts = file.webkitRelativePath.split('/');
                pathParts.forEach((part, index) => {
                    if (currentPath[index] !== part) {
                        currentPath = currentPath.slice(0, index);
                        currentPath[index] = part;
                        const isDir = index < pathParts.length - 1;
                        output += "  ".repeat(index) + part + (isDir ? "/" : "") + "\n";
                    }
                });
            });
            inputArea.value = output.trim();
            generateTree();
            updateBreadcrumb();
        });

        inputArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            inputArea.classList.add('drag-over');
        });

        inputArea.addEventListener('dragleave', () => {
            inputArea.classList.remove('drag-over');
        });

        inputArea.addEventListener('drop', async (e) => {
            if (e.dataTransfer.types.includes('text/plain')) return; 
            e.preventDefault();
            inputArea.classList.remove('drag-over');
            const items = e.dataTransfer.items;
            if (!items) return;
            let fullOutput = "";
            const entries = [];
            for (let i = 0; i < items.length; i++) {
                const entry = items[i].webkitGetAsEntry();
                if (entry) entries.push(entry);
            }
            const exclusions = getExclusions();
            for (const entry of entries) {
                fullOutput += await traverseEntry(entry, 0, exclusions);
            }
            inputArea.value = fullOutput.trim();
            generateTree();
            updateBreadcrumb();
        });

        async function traverseEntry(entry, depth, exclusions) {
            if (exclusions.includes(entry.name)) return "";

            let result = " ".repeat(depth * 2) + entry.name + (entry.isDirectory ? "/" : "") + "\n";
            if (entry.isDirectory) {
                const dirReader = entry.createReader();
                const entries = await new Promise((resolve) => {
                    dirReader.readEntries((results) => resolve(results));
                });
                for (const child of entries) {
                    result += await traverseEntry(child, depth + 1, exclusions);
                }
            }
            return result;
        }

        // SCRIPTED TEXT EXTRACTION (Strips all UI artifacts)
        function getCleanTreeText() {
            const treeLines = getRawASCIIArray();
            return treeLines.map(l => l.text).join('\n');
        }

        function copyAsMarkdown() {
            const text = getCleanTreeText();
            if (!text) return;
            copyInternal("```text\n" + text + "\n```");
            showToast("COPIED AS MARKDOWN");
        }

        function copyToClipboard() {
            const text = getCleanTreeText();
            if (!text) return;
            copyInternal(text);
            const originalText = copyBtn.innerText;
            copyBtn.classList.add('clicked');
            copyBtn.innerText = "COPIED";
            showToast();
            setTimeout(() => {
                copyBtn.classList.remove('clicked');
                copyBtn.innerText = originalText;
            }, 800);
        }

        function copyInternal(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
        }

        async function updateURL() {
            const val = inputArea.value;
            localStorage.setItem('struktur_content', val);

            try {
                const encoded = await compressData(val);
                let params = new URLSearchParams();
                if (styleSelect.value !== 'round') params.set('s', styleSelect.value);
                if (!showIcons) params.set('i', '0');
                if (showFullPaths) params.set('p', '1'); 
                
                const paramStr = params.toString();
                const newHash = "#" + encoded + (paramStr ? "?" + paramStr : "");
                
                if (window.location.hash !== newHash) {
                    if (window.history && typeof window.history.replaceState === 'function') {
                        window.history.replaceState(null, null, newHash);
                    } else {
                        window.location.hash = newHash;
                    }
                }
            } catch (e) {
                console.warn("URL Update failed:", e.message);
            }
        }

        async function loadFromURL() {
            try {
                const fullHash = window.location.hash.substring(1);
                if (fullHash) {
                    const [data, query] = fullHash.split('?');
                    const params = new URLSearchParams(query || "");
                    if (params.has('s')) styleSelect.value = params.get('s');
                    if (params.get('i') === '0') {
                        showIcons = false;
                        toggleIconsBtn.classList.remove('active');
                    }
                    if (params.get('p') === '1') {
                        showFullPaths = true;
                        document.getElementById('fullPathToggleBtn').classList.add('active');
                    }
                    const decoded = await decompressData(data);
                    inputArea.value = decoded;
                } else {
                    const saved = localStorage.getItem('struktur_content');
                    inputArea.value = saved || INITIAL_EXAMPLE;
                }
            } catch (e) {
                inputArea.value = INITIAL_EXAMPLE;
            }
            generateTree();
            updateBreadcrumb();
            checkHeaderCollisions(); 
        }

        function generateTree() {
            const rawLines = inputArea.value.split('\n');
            let hasTabs = false;
            let hasSpaces = false;
            for (let line of rawLines) {
                if (line.startsWith('\t')) hasTabs = true;
                if (line.startsWith(' ')) hasSpaces = true;
                if (hasTabs && hasSpaces) break;
            }
            indentWarn.classList.toggle('visible', hasTabs && hasSpaces);

            const nodes = rawLines.map(l => {
                let name = l;
                let annotation = "";
                let isIgnored = false;
                const hashIdx = name.indexOf('#');
                if (hashIdx !== -1) {
                    if (name.trim().startsWith('#')) isIgnored = true;
                    name = name.substring(0, hashIdx);
                }
                const dsIdx = name.indexOf('//');
                if (dsIdx !== -1) {
                    annotation = name.substring(dsIdx + 2).trim();
                    name = name.substring(0, dsIdx);
                }
                name = name.trim();
                return { 
                    indent: l.search(/\S/), 
                    name: name,
                    annotation: annotation,
                    isComment: isIgnored || (name === "" && annotation === "" && l.trim() !== "")
                };
            });

            outputArea.innerHTML = buildTreeHTML(nodes);
            updateURL();
        }

        function handleTreeSearch() {
            generateTree();
        }

        function showToast(msg = "COPIED TO CLIPBOARD") {
            toast.innerText = msg;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 1500);
        }

        function clearInput() {
            inputArea.value = "";
            generateTree();
            updateBreadcrumb();
            inputArea.focus();
        }

        // README GENERATOR LOGIC
        function generateReadme() {
            const tree = getCleanTreeText();
            const projectName = breadcrumb.innerText.split('/')[0].trim() || "Project";
            
            const content = `# ${projectName}\n\n## Project Structure\n\n\`\`\`text\n${tree}\n\`\`\`\n\n---\n*Generated by [Strukture](https://strukture.ableproman.hu)*`;
            
            showModal({
                title: "README GENERATOR",
                message: "Your project structure README.md content is ready:",
                confirmText: "CLOSE"
            });
            
            const body = document.getElementById('modalBody');
            body.innerHTML += `
                <div style="margin-top:15px">
                    <textarea id="readmeOutput" class="modal-input" style="height: 200px; font-family: var(--font-mono); font-size: 0.8rem; margin-bottom: 10px;" readonly>${content}</textarea>
                    <button class="action-btn primary" style="width: 100%; justify-content: center;" onclick="copyInternal(document.getElementById('readmeOutput').value); showToast('README COPIED')">Copy README Content</button>
                </div>
            `;
        }

        // Share Feature Logic
        function shareLink() {
            const url = window.location.href;
            modalTitle.innerText = "SHARE STRUCTURE";
            modalBody.innerHTML = `
                <div style="margin-bottom: 12px; font-size: 0.85rem; color: var(--text-dim);">Share this project structure with others using the link below:</div>
                <div style="background: #000; border: 1px solid var(--border-color); padding: 12px; font-family: var(--font-mono); font-size: 0.75rem; word-break: break-all; color: var(--accent-color); margin-bottom: 20px; max-height: 100px; overflow-y: auto; text-align: left;">${url}</div>
                <button class="action-btn primary" style="width: 100%; justify-content: center; height: 40px;" onclick="copyInternal('${url}'); modalOverlay.classList.remove('visible'); showToast('LINK COPIED');">Copy Shareable Link</button>
            `;
            modalInput.style.display = 'none';
            modalCancel.style.display = 'block';
            modalConfirm.style.display = 'none';
            modalOverlay.classList.add('visible');
        }

        // HELP, PRIVACY, TERMS FUNCTIONS (PROFESSIONAL HTML FORMAT)
        function showHelp() {
            showModal({
                title: "STRUKTURE HELP & GUIDE",
                message: `
                    <div style="text-align: left;">
                        <p>Welcome to <strong>Strukture</strong>, the developer's favorite tool for rapid ASCII visualization. Follow these steps to master the workflow:</p>
                        <h3 style="margin-top:15px; color:var(--text-main);">1. Hierarchy Syntax</h3>
                        <p>Type your folders and files directly into the <strong>Source</strong> panel. Folders are defined by names ending in a slash (<strong>/</strong>), while files have no slash. Indentation levels (spaces or tabs) define the depth.</p>
                        
                        <h3 style="margin-top:15px; color:var(--text-main);">2. Auto-Refactor (Magic 3)</h3>
                        <p>Click the <strong>Auto-Refactor</strong> button to instantly perform three critical operations:
                            <ul>
                                <li><strong>Fix Indent</strong>: Aligns all lines to a consistent 2-space standard.</li>
                                <li><strong>Auto-Sort</strong>: Alphabetically organizes files and folders while keeping comments attached.</li>
                                <li><strong>Auto-Slash</strong>: Detects folder structures and ensures they end with a slash.</li>
                            </ul>
                        </p>
                        
                        <h3 style="margin-top:15px; color:var(--text-main);">3. Annotations & Comments</h3>
                        <p>Add <strong>//</strong> inline to annotate specific files for your documentation. Use <strong>#</strong> at the start of a line for developer notes that won't appear in the ASCII connectors.</p>
                        
                        <h3 style="margin-top:15px; color:var(--text-main);">4. Export Options</h3>
                        <p>Use <strong>PNG</strong> or <strong>SVG</strong> for high-quality visuals in your GitHub READMEs. The <strong>CLI Tool</strong> generates actual <code>mkdir</code> and <code>touch</code> commands to recreate the structure on your local machine.</p>
                    </div>
                `,
                confirmText: "GOT IT"
            });
        }

        function showPrivacy() {
            showModal({
                title: "PRIVACY POLICY",
                message: `
                    <div style="text-align: left;">
                        <p><strong>Last Updated: January 2026</strong></p>
                        <p>At <strong>Strukture</strong>, privacy is a fundamental design principle, not an afterthought. This policy explains our "Privacy by Local-Only Design" framework.</p>
                        
                        <h3>1. Data Sovereignty</h3>
                        <p>Your project data never leaves your computer. All ASCII generation, tree processing, and file exports are performed entirely in your browser's local memory using client-side JavaScript. We do not maintain any central database of project structures.</p>
                        
                        <h3>2. AI Processing & API Keys</h3>
                        <p>When utilizing the <strong>AI Architect</strong> or <strong>AI Review</strong> features:
                            <ul>
                                <li><strong>BYOK (Bring Your Own Key)</strong>: We do not provide AI services directly. You must provide your own Gemini API key.</li>
                                <li><strong>Key Security</strong>: Your key is obfuscated (hashed) and stored locally in your browser's IndexedDB/LocalStorage. It is never transmitted to our servers.</li>
                                <li><strong>Request Transparency</strong>: Data sent to Google Gemini is strictly limited to your provided project hierarchy and prompt. Review Google's AI Privacy Policy for their data handling.</li>
                            </ul>
                        </p>

                        <h3>3. Local Storage & Persistence</h3>
                        <p>We utilize the following browser technologies for your convenience:
                            <ul>
                                <li><strong>IndexedDB</strong>: Used solely to store your "Saved Structures" locally on your device.</li>
                                <li><strong>URL Hash</strong>: Your current working structure is compressed into the URL fragment (after the #). This allows you to share structures by copying the URL without creating an account.</li>
                            </ul>
                        </p>
                        
                        <h3>4. GitHub API Interaction</h3>
                        <p>When you use the <strong>GitHub Import</strong> feature, your browser makes a direct request to the GitHub public API. Strukture does not act as a middleman, nor do we log which repositories you import.</p>
                        
                        <h3>5. Third-Party Analytics</h3>
                        <p>Strukture does not use tracking pixels, Google Analytics, or invasive cookies. We are a developer-focused tool built on trust and transparency.</p>
                    </div>
                `,
                confirmText: "CLOSE"
            });
        }

        function showTerms() {
            showModal({
                title: "TERMS OF SERVICE",
                message: `
                    <div style="text-align: left;">
                        <p><strong>Effective Date: January 2026</strong></p>
                        <p>By using the <strong>Strukture</strong> web application, you agree to the following legally binding terms of use:</p>
                        
                        <h3>1. License to Output</h3>
                        <p>All ASCII trees, diagrams, and code generated by Strukture are provided under a <strong>Creative Commons Zero (CC0)</strong> license. You are free to use, modify, and distribute these outputs in commercial documentation, software repositories, and marketing materials without attribution.</p>
                        
                        <h3>2. AI Features & Third-Party Keys</h3>
                        <p>By using the AI Architect or AI Review:
                            <ul>
                                <li>You represent that you have the right to use the API key provided.</li>
                                <li>You understand that AI output is generated by Google Gemini and may contain inaccuracies.</li>
                                <li>We are not responsible for any API costs or quota limitations incurred on your personal Google Cloud/AI Studio account.</li>
                            </ul>
                        </p>

                        <h3>3. User Responsibility</h3>
                        <p>You are solely responsible for the content you type or import. While Strukture is a visualization tool, you agree not to use it to generate structures meant for malicious purposes or representing illegal digital material.</p>
                        
                        <h3>4. Limitation of Liability</h3>
                        <p>The application is provided <strong>"AS IS"</strong>, without warranty of any kind. Under no circumstances shall <strong>AbleProMan</strong> or the developers be liable for any special, incidental, indirect, or consequential damages arising from data loss, system errors while running CLI commands, or use of the exported files.</p>
                        
                        <h3>5. CLI Command Caution</h3>
                        <p>The <strong>CLI Tool</strong> generate shell commands for your terminal. You must <strong>review every line</strong> of generated code before executing it. We are not responsible for unintended folder deletions or system impacts caused by executing these commands.</p>
                    </div>
                `,
                confirmText: "I AGREE & CLOSE"
            });
        }

        // RESPONSIVE HEADER COLLISION LOGIC
        function checkHeaderCollisions() {
            ['source', 'tree'].forEach(type => {
                const header = document.getElementById(type + 'Header');
                const title = header.querySelector('.panel-title');
                const btnGroup = document.getElementById(type + 'Btns');
                const hamburger = document.getElementById(type + 'Hamburger');
                const mobileMenu = document.getElementById(type + 'MobileMenu');
                
                if (!btnGroup.hasAttribute('data-orig-width')) {
                    const wasInMobile = btnGroup.parentElement === mobileMenu;
                    if (wasInMobile) header.appendChild(btnGroup);
                    
                    const width = btnGroup.scrollWidth;
                    if (width > 0) {
                        btnGroup.setAttribute('data-orig-width', width);
                    }
                    
                    if (wasInMobile) mobileMenu.appendChild(btnGroup);
                }

                const headerWidth = header.getBoundingClientRect().width;
                const titleWidth = title.getBoundingClientRect().width;
                const origBtnWidth = parseInt(btnGroup.getAttribute('data-orig-width') || "0");
                const padding = 40; 
                const gap = 20;

                if (headerWidth - padding < (titleWidth + origBtnWidth + gap)) {
                    if (btnGroup.parentElement === header) {
                        mobileMenu.appendChild(btnGroup);
                        hamburger.style.display = 'block';
                    }
                } else {
                    if (btnGroup.parentElement === mobileMenu) {
                        header.appendChild(btnGroup);
                        hamburger.style.display = 'none';
                        mobileMenu.classList.remove('open');
                    }
                }
            });
        }

        function toggleMobileMenu(type) {
            const menu = document.getElementById(type + 'MobileMenu');
            menu.classList.toggle('open');
        }
        
        document.querySelectorAll('.mobile-menu').forEach(menu => {
            menu.addEventListener('click', (e) => {
                const isBtn = e.target.closest('.action-btn');
                if (isBtn) {
                    menu.classList.remove('open');
                }
            });
        });

        window.addEventListener('resize', checkHeaderCollisions);

        // UNDO / REDO SYSTEM
        let history = [INITIAL_EXAMPLE];
        let historyIndex = 0;
        const maxHistory = 100;

        function saveHistory() {
            const current = inputArea.value;
            if (current === history[historyIndex]) return;
            
            history = history.slice(0, historyIndex + 1);
            history.push(current);
            if (history.length > maxHistory) history.shift();
            else historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                inputArea.value = history[historyIndex];
                generateTree();
                updateBreadcrumb();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                inputArea.value = history[historyIndex];
                generateTree();
                updateBreadcrumb();
            }
        }

        inputArea.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                } else if (e.key.toLowerCase() === 'y') {
                    e.preventDefault();
                    redo();
                } else if (e.key.toLowerCase() === 's') {
                    e.preventDefault();
                    saveWithShortcut();
                }
            }
        });

        // ADVANCED DELETE LOGIC
        async function handleDeleteNode(index) {
            const rawLines = inputArea.value.split('\n');
            const targetLine = rawLines[index];
            if (targetLine === undefined) return;

            const targetIndent = targetLine.search(/\S/);
            const isFolder = targetLine.trim().endsWith('/') || 
                             (rawLines[index+1] && rawLines[index+1].search(/\S/) > targetIndent);

            if (!isFolder) {
                rawLines.splice(index, 1);
                inputArea.value = rawLines.join('\n');
                handleTextChange();
                return;
            }

            modalTitle.innerText = "DELETE FOLDER";
            modalBody.innerText = `Choose how you want to remove the folder "${targetLine.trim()}":`;
            modalInput.style.display = 'none';
            modalCancel.style.display = 'none'; 
            modalConfirm.style.display = 'none'; 
            
            const footer = document.getElementById('modalFooter');
            let folderBtns = document.getElementById('folderDeleteExtra');
            if (!folderBtns) {
                folderBtns = document.createElement('div');
                folderBtns.id = 'folderDeleteExtra';
                folderBtns.style.display = 'flex';
                folderBtns.style.gap = '12px';
                footer.appendChild(folderBtns);
            }
            folderBtns.style.display = 'flex';
            
            folderBtns.innerHTML = `
                <button class="action-btn" id="delCancel">Cancel</button>
                <button class="action-btn" id="delKeep">Keep Files</button>
                <button class="action-btn primary" id="delAll">Delete All</button>
            `;
            
            modalOverlay.classList.add('visible');

            const resolveDelete = (choice) => {
                modalOverlay.classList.remove('visible');
                folderBtns.style.display = 'none';
                modalCancel.style.display = 'block';
                modalConfirm.style.display = 'block';

                if (choice === 'all') {
                    let end = index + 1;
                    while (end < rawLines.length && rawLines[end].search(/\S/) > targetIndent) {
                        end++;
                    }
                    rawLines.splice(index, end - index);
                } else if (choice === 'keep') {
                    let indentUnit = 0;
                    for (let i = 0; i < rawLines.length; i++) {
                        const ind = rawLines[i].search(/\S/);
                        if (ind > 0) { indentUnit = ind; break; }
                    }
                    if (indentUnit === 0) indentUnit = 2;

                    rawLines.splice(index, 1);
                    let i = index;
                    while (i < rawLines.length && rawLines[i].search(/\S/) > targetIndent) {
                        const currentIndent = rawLines[i].search(/\S/);
                        const content = rawLines[i].trim();
                        rawLines[i] = " ".repeat(Math.max(0, currentIndent - indentUnit)) + content;
                        i++;
                    }
                } else {
                    return; 
                }

                inputArea.value = rawLines.join('\n');
                handleTextChange();
            };

            document.getElementById('delCancel').onclick = () => resolveDelete('cancel');
            document.getElementById('delKeep').onclick = () => resolveDelete('keep');
            document.getElementById('delAll').onclick = () => resolveDelete('all');
        }

        // REVERSE PARSER LOGIC
        function showReverseParser() {
            modalTitle.innerText = "REVERSE PARSER";
            modalBody.innerHTML = `
                <div style="margin-bottom: 12px; font-size: 0.85rem; color: var(--text-dim);">Paste a raw ASCII tree below to convert it back to editable source format:</div>
                <textarea id="reverseParserInput" class="modal-input" style="height: 150px; resize: vertical;" placeholder="Paste tree here..."></textarea>
                <div style="margin-top: 15px;">
                    <button class="action-btn primary" style="width: 100%; justify-content: center; height: 40px;" onclick="handleReverseParseAction()">CONVERT TO SOURCE</button>
                </div>
            `;
            modalInput.style.display = 'none';
            modalCancel.style.display = 'block';
            modalConfirm.style.display = 'none';
            modalOverlay.classList.add('visible');
            setTimeout(() => document.getElementById('reverseParserInput').focus(), 150);
        }

        function handleReverseParseAction() {
            const val = document.getElementById('reverseParserInput').value;
            if (!val.trim()) return;

            const parsed = reverseParseLogic(val);
            if (parsed) {
                inputArea.value = parsed;
                handleTextChange();
                modalOverlay.classList.remove('visible');
                showToast("TREE REVERSE PARSED");
            } else {
                showToast("FAILED TO PARSE TREE");
            }
        }

        function reverseParseLogic(text) {
            const lines = text.split('\n').filter(l => l.trim() !== "");
            const resultLines = [];
            
            lines.forEach(line => {
                const match = line.match(/([a-zA-Z0-9._\-\(\)\[\]\{\}]+.*)/);
                if (!match) return;

                const nameAndExtra = match[1];
                const leadingPart = line.substring(0, line.indexOf(nameAndExtra));
                const depth = Math.floor(leadingPart.length / 4);
                
                resultLines.push("  ".repeat(depth) + nameAndExtra.trim());
            });

            return resultLines.join('\n');
        }

        // 3-IN-1 MAGIC BUTTON (FIXED FOR COMMENT PRESERVATION)
        function runMagicThree() {
            fixIndentation();
            autoSortSource();
            autoFixFolders();
            showToast("MAGIC 3 APPLIED");
        }

        // INDEXED DB INTEGRATION
        const DB_NAME = "StruktureDB";
        const DB_VERSION = 1;
        const STORE_NAME = "structures";
        
        let currentLoadedId = null;

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
                    }
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveToDB() {
            const content = inputArea.value;
            if (!content.trim()) return showToast("INPUT IS EMPTY");

            const name = await customPrompt("Save Structure As:", "My Awesome Project");
            if (!name) return;

            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, "readwrite");
                const store = tx.objectStore(STORE_NAME);
                await new Promise((resolve, reject) => {
                    const req = store.add({ name, content, timestamp: Date.now() });
                    req.onsuccess = (e) => {
                        currentLoadedId = e.target.result; 
                        resolve();
                    };
                    req.onerror = reject;
                });
                showToast("SAVED TO DATABASE");
            } catch (e) {
                console.error(e);
                showToast("SAVE FAILED");
            }
        }

        async function saveWithShortcut() {
            const content = inputArea.value;
            if (!content.trim()) return showToast("INPUT IS EMPTY");

            if (currentLoadedId) {
                try {
                    const db = await openDB();
                    const tx = db.transaction(STORE_NAME, "readwrite");
                    const store = tx.objectStore(STORE_NAME);
                    
                    const item = await new Promise((resolve) => {
                        const req = store.get(currentLoadedId);
                        req.onsuccess = () => resolve(req.result);
                    });

                    if (item) {
                        item.content = content;
                        item.timestamp = Date.now();
                        await new Promise((resolve) => {
                            const req = store.put(item);
                            req.onsuccess = resolve;
                        });
                        showToast("SAVED"); 
                        return;
                    }
                } catch (e) {
                    console.error("Smart save failed, falling back to prompt", e);
                }
            }
            saveToDB();
        }

        async function autoSaveToDB() {
            const content = inputArea.value;
            if (!content.trim()) return;
            localStorage.setItem('struktur_autosave', content);
        }

        async function showSavedStructures() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, "readonly");
                const store = tx.objectStore(STORE_NAME);
                const items = await new Promise((resolve) => {
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                });

                modalTitle.innerText = "MY SAVED STRUCTURES";
                if (items.length === 0) {
                    modalBody.innerHTML = `<div style="text-align:center; padding: 20px; opacity: 0.5;">No structures saved yet.</div>`;
                } else {
                    modalBody.innerHTML = `
                        <div style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;">
                            ${items.map(item => `
                                <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; border: 1px solid var(--border-color);">
                                    <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;">
                                        <div style="font-weight: bold; font-size: 0.9rem;">${item.name}</div>
                                        <div style="font-size: 0.65rem; opacity: 0.4;">${new Date(item.timestamp).toLocaleString()}</div>
                                    </div>
                                    <div style="display: flex; gap: 6px;">
                                        <button class="action-btn primary" style="padding: 4px 8px; font-size: 0.65rem;" onclick="loadSaved(${item.id})">LOAD</button>
                                        <button class="action-btn" style="padding: 4px 8px; font-size: 0.65rem; color: var(--error-color); border-color: rgba(255,68,68,0.2);" onclick="deleteSaved(${item.id})">DEL</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="margin-top: 15px; border-top: 1px solid var(--border-color); padding-top: 15px;">
                            <button class="action-btn" style="width: 100%; justify-content: center;" onclick="bulkExportDB()">BULK EXPORT ALL (JSON)</button>
                        </div>
                    `;
                }
                modalInput.style.display = 'none';
                modalCancel.style.display = 'block';
                modalConfirm.style.display = 'none';
                modalOverlay.classList.add('visible');
            } catch (e) {
                showToast("COULD NOT FETCH DB");
            }
        }

        async function bulkExportDB() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, "readonly");
                const store = tx.objectStore(STORE_NAME);
                const items = await new Promise((resolve) => {
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                });
                
                if (items.length === 0) return showToast("DATABASE IS EMPTY");

                const blob = new Blob([JSON.stringify(items, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `strukture_backup_${new Date().toISOString().slice(0,10)}.json`;
                a.click();
                showToast("BACKUP DOWNLOADED");
            } catch (e) {
                showToast("EXPORT FAILED");
            }
        }

        async function loadSaved(id) {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, "readonly");
                const store = tx.objectStore(STORE_NAME);
                const item = await new Promise((resolve) => {
                    const req = store.get(id);
                    req.onsuccess = () => resolve(req.result);
                });
                if (item) {
                    currentLoadedId = id; 
                    inputArea.value = item.content;
                    handleTextChange();
                    modalOverlay.classList.remove('visible');
                    showToast("STRUCTURE LOADED");
                }
            } catch (e) {
                showToast("LOAD FAILED");
            }
        }

        async function deleteSaved(id) {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, "readwrite");
                const store = tx.objectStore(STORE_NAME);
                await new Promise((resolve, reject) => {
                    const req = store.delete(id);
                    req.onsuccess = resolve;
                    req.onerror = reject;
                });
                if (currentLoadedId === id) currentLoadedId = null;
                showSavedStructures(); 
                showToast("DELETED");
            } catch (e) {
                showToast("DELETE FAILED");
            }
        }

        // --- GEMINI AI INTEGRATION LOGIC ---
        
        const apiKey = ""; 

        async function getSecureKey() {
            const stored = localStorage.getItem('sk_ai_hash');
            if (!stored) return null;
            try {
                const data = atob(stored);
                const decoded = new Uint8Array(data.length);
                for(let i=0; i<data.length; i++) decoded[i] = data.charCodeAt(i) ^ 42;
                return new TextDecoder().decode(decoded);
            } catch (e) {
                return null;
            }
        }

        async function saveSecureKey(key) {
            if (!key) {
                localStorage.removeItem('sk_ai_hash');
                return;
            }
            const encoder = new TextEncoder();
            const data = encoder.encode(key);
            const obfuscated = btoa(String.fromCharCode(...data.map(b => b ^ 42)));
            localStorage.setItem('sk_ai_hash', obfuscated);
        }

        async function configureAI() {
            const current = await getSecureKey();
            const val = await customPrompt(`Set Gemini API Key: ${current ? '(Key exists)' : '(Not set)'}`, "Paste AI Key here...");
            if (val !== null) {
                await saveSecureKey(val.trim());
                showToast(val ? "KEY UPDATED" : "KEY REMOVED");
            }
        }

        async function generateWithAI() {
            const key = await getSecureKey() || apiKey;
            if (!key) {
                customAlert("Please set your Gemini API Key in 'AI Config' first.");
                return;
            }

            const prompt = await customPrompt("What structure should the AI Architect build?", "e.g. A modern e-commerce backend with Node.js and Redis");
            if (!prompt) return;

            showToast("AI ARCHITECT IS THINKING...");
            
            try {
                const result = await fetchGemini(prompt, key, true);
                if (result) {
                    inputArea.value = result.trim();
                    handleTextChange();
                    showToast("STRUCTURE GENERATED");
                }
            } catch (e) {
                customAlert("AI Error: " + e.message);
            }
        }

        // NEW: AI AUDIT FUNCTION (WITH COPY SUPPORT)
        async function auditWithAI() {
            const key = await getSecureKey() || apiKey;
            if (!key) {
                customAlert("Please set your Gemini API Key in 'AI Config' first.");
                return;
            }

            const currentTree = getCleanTreeText();
            if (!currentTree || currentTree.length < 5) {
                customAlert("Please create a structure first before running a review.");
                return;
            }

            showToast("AI IS REVIEWING YOUR ARCHITECTURE...");

            const auditPrompt = `Analyze the following software project directory structure. Provide 3-5 professional, concise, and constructive architectural suggestions to improve it. Focus on best practices, folder organization, and potential missing standard files.

            Directory Structure:
            ${currentTree}`;

            try {
                const reviewText = await fetchGemini(auditPrompt, key, false);
                if (reviewText) {
                    showModal({
                        title: "AI ARCHITECTURAL REVIEW",
                        message: `
                            <div id="aiReviewContent" style="text-align:left; font-size: 0.9rem; line-height: 1.6; margin-bottom: 20px;">${reviewText.replace(/\n/g, '<br>')}</div>
                            <div style="border-top: 1px solid var(--border-color); padding-top: 15px;">
                                <button class="action-btn primary" style="width: 100%; justify-content: center;" onclick="copyInternal(document.getElementById('aiReviewContent').innerText); showToast('REVIEW COPIED')">COPY REVIEW TEXT</button>
                            </div>
                        `,
                        confirmText: "CLOSE"
                    });
                }
            } catch (e) {
                customAlert("AI Review Error: " + e.message);
            }
        }

        async function fetchGemini(userQuery, key, isHierarchyRequest) {
            const model = "gemini-2.5-flash";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;
            
            const systemPrompt = isHierarchyRequest 
                ? `You are a professional software architect. Generate a plain text directory structure (file tree) based on the user's request. Rules: 1. Use 2-space indentation. 2. Folders MUST end with a trailing slash (/). 3. Files MUST NOT end with a slash. 4. Do NOT use Markdown code blocks or backticks. 5. Return ONLY the raw hierarchy text. 6. Do not include any explanations or conversational text.`
                : `You are a professional software architect providing a code review. Analyze the provided directory structure. Be concise, technical, and helpful. Use plain text only, no markdown formatting.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] }
            };

            let delay = 1000;
            for (let i = 0; i < 5; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.candidates?.[0]?.content?.parts?.[0]?.text;
                    }
                    
                    if (response.status !== 429 && response.status < 500) {
                        const errData = await response.json();
                        throw new Error(errData.error?.message || "API Error");
                    }
                } catch (err) {
                    if (i === 4) throw err;
                }
                await new Promise(res => setTimeout(res, delay));
                delay *= 2;
            }
            throw new Error("Maximum retries reached.");
        }

        window.onload = loadFromURL;
    </script>
</body>
</html>